/***************************************************************************************
*cr								
*cr					Copyright (c) 2004, The Regents of the 
*cr	University of California, through Lawrence Berkeley National Laboratory, 
*cr	Univ. of Calif. at Davis, and Lawrence Livermore National Laboratory 
*cr	(subject to receipt of any required approvals from U.S. Dept. of Energy).  
*cr							All rights reserved.
*cr		
*cr		Please see the accompanying LICENSE file for further information.
*cr
***************************************************************************************/
/*
BuildBeta: Uses probability results of Ingo Ruczinski's PhD thesis on
protein fold topology, and of Zhu and Braun on sequence matching
specificity between adjacent strands in a sheet, to automatically
produce a higher probability collection of possible initial sheet
conformations, and write them out to separate files.
The variables discussed below can be initialized in the BuildBeta section
of the ProteinShop.cfg file.

If the variable shorten is greater than 0, the predicted strands will
be shortened to account for the limits of matching with any adjacent strands
in order to allow more flexibility in the adjacent coil regions. When
this is done, the energy estimate is increased by the beta strand
prediction certainty times strand_to_coil_penalty. If the variable
interact is non-zero, the program stops after every structure is attempted
and asks in the command line window whether the user wants an early
return in order to examine the structure attempt with interactive graphics.
If interact > 1 ,the program stops multiple times per structure, once
when each beta strand moves, once after every motion of
an alpha helix that is being positioned parallel to the beta sheet,
and once after every correction motion to put the beta sheet back together
if the attempted motion of the alpha helix broke it.
If the variable flatten is non-zero, the beta strands are flattened.
If the variable optimized_angles is zero, the beta strands are flattened
using standard phi and psi angles which make them planar, or close to planar,
depending on the values set below for flatPhi and flatPsi. If it is non-zero
optimized angles depending on the amino acid position, strand length, and
"up" directions of adjacent strands are used. These angles were optimized
using polyalanine, and fake forces to favor hydrogen bonds.
If offlineBuildBeta is equal to 1, the program will proceed directly to create
the conformation files without any display or user input. Otherwise, the
graphics display will be initialized, and the BuildBeta routine can be
called by typing a 'd' with the cursor on the graphics display window.
The variable flatfrac is the fraction
of the way between the nominal beta strand phi and psi angles in the
middle of the distribution on the Ramachandran plot, and the completely
flattened values for no twist in the strand.
The variable spacing is the distance between the beta sheet and any alpha
helices that are automatically placed parallel to it, and also between the
layers of alpha helices, if further layers are needed because more than
one alpha helix separated two beta strands in the sequence.

The current implementation is limited to ten strands or less, which is
the limit of Ingo Ruczinski's data fitting, and makes no attempt to make
two or more sheets; all beta strands are placed in one beta sheet.
The values TWO, THRE, FOUR, and FIVE below can be changed in the source to
modify the number of structures that will be attempted.

The program outputs each structure twice, once before the alpha helix
motion attempt, and again if this attempt succeeds, overwriting the
first version. If the alpha helix motion does not succeed, the first
file written remains, with a correct beta sheet, but perhaps with alpha
helices intersecting it. The program makes no attempt to move loops
out of the way of the sheet.

The array position maps the beta strands in the sequence order to the
left to right order in the sheet, and the array positionInverse maps
the strand order in the sheet to the order in the sequence. Possible
sheet topologies are generated by considering all permutations for the 
array position, the two possible sides of the first strand in the sheet
for hydrogen bonding to the second, and candidate matches evaluated by
the energy of Zhu and Braun. 

************************************************************************/

#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <stdexcept>
#include <Math/Math.h>
#include <GLTemplates.h>
#include <GLGeometry.h>
#include <GLTransformations.h>
#include <FL/Fl.H>

#include "MyFlGlWindow.h"

#include "Globals.h"
#include "Protein.h"

#define LARGE 40000000
#define MAXRES 1400
#define MAX_STRANDS 11
#define MAX_ALPHA 30
#define MAX_ALPHA_BETWEEN_BETA 10
#define THRESHOLD .01
#define TWO  2  // number of repeated pair alignments allowed in best FOUR
#define THRE 4  // number of matching alignments saved per strand pair
#define FOUR 6  // number of alignments saved for all strands
#define FIVE 5  // number of sheet topologies saved, each counted twice
                // for the two possible rotations of first strand, which,
		// together with the matches, determines the orientations
		// of all subsequent strands in the sheet. This is for the
		// 3 strand case only. For 5 or more strands this number
		// is try_topologies, set in ProteinShop.cfg.
#define ALIGNMENTS 4 // number of alignments per odd value per topology
                     // successfully constructed before breaking from loop
#define FIND_PER_TOPOLOGY 2 // number of succusfully built topologies
                     // required to increment successful topololgy count
#define MAXTOP 20    // number of topologies of equal Ruczinski score saved
int enough_topologies = 6; // number of different topologies with at least 
                     // FIND_PER_TOPOLOGY successes that should be found
                     // can also be set in configuration file
int try_topologies = 11;  // number of topologies to be attempted
                     // can also be set in configuration file
int test_zip = 1;    // set to test whether proposed Zhu and Braun matches
                     // can actually be achieved in findCaseBestFOUR.
int move_helices = 1;  // to move helices parallel to the beta sheet

/* Hack: External global variable to access last IK iteration's residual: */
double lastIKResidual = 0.0;    // class Joint disappeared, assume it works
extern int conf[], is_core[], has_core;
extern char inputfilename[];
extern MyFlGlWindow *renderWindow;
extern char pred[MAXRES];
int offlineBuildBeta = 0;
float spacing = 6.;
float strand_to_coil_penalty = 0.;
float flatfrac = .5;
float flflatPhi = -131.85, flflatPsi = 128.15; // completely flattened values
float flatPhi = -126., flatPsi = 134.; // Average of nominal and flattened values
float raflatPhi = -120., raflatPsi = 140.; // nominal beta strand values
typedef ProteinInteractor::Transformation Transformation;
typedef Transformation::Vector Vector;
 
extern void applyTransformation(const ProteinInteractor::Transformation& transformation);

namespace MD {

extern bool writePdbFile(const Protein& protein,const char* filename,bool writeStructure =true);
int *Zhu, betaCount, totalResidues, doTerms = 2, shorten = 1, // 2 for printing
   interact = 1, optimized_angles = 0, flatten = 1, found, inserted, remove;
float plane[MAX_STRANDS][3], center[MAX_STRANDS][3];

float Pcount[6][7][4][2][2][6];

int position[MAX_STRANDS], up[MAX_STRANDS], coilLength[MAX_STRANDS],
   betaLength[MAX_STRANDS], nCoilPieces[MAX_STRANDS], isLong[MAX_STRANDS],
   coilPiece[MAX_STRANDS][MAX_ALPHA_BETWEEN_BETA + 1], placed[MAX_STRANDS],
   alphaPiece[MAX_STRANDS][MAX_ALPHA_BETWEEN_BETA], betaPiece[MAX_STRANDS],
   positionInverse[MAX_STRANDS],
   oddStart[MAX_STRANDS], twoPower[MAX_STRANDS], bestOddStart[MAX_STRANDS][THRE],
   start[MAX_STRANDS - 1], bestStart[MAX_STRANDS - 1][THRE],
   betaStart[MAX_STRANDS], repeat[MAX_STRANDS - 1],
   tempStart[MAX_STRANDS], THRE_power[MAX_STRANDS - 1], choice[MAX_STRANDS - 1],
   bestTotalStart[MAX_STRANDS - 1][FOUR + 1], 
   bestBegin[MAX_STRANDS][FOUR + 1], bestEnd[MAX_STRANDS][FOUR + 1],helical,
   alphaBegin[MAX_ALPHA], alphaEnd[MAX_ALPHA], firstCoil[MAX_STRANDS],
   lastCoil[MAX_STRANDS], nAlphaPieces[MAX_STRANDS],
   coreCoil[MAX_STRANDS][MAX_ALPHA_BETWEEN_BETA + 1], coreAlpha[MAX_ALPHA],
   coreBeta[MAX_STRANDS], core_edge[MAX_STRANDS][2], firstCoreBeta,
   lastCoreBeta, bestStartTest[MAX_STRANDS - 1][THRE][4],
   foundA[MAX_STRANDS - 1][4];
   

float bestE[MAX_STRANDS - 1][THRE], bestEtest[MAX_STRANDS - 1][THRE][4],
   bestTotalE[FOUR + 1];
float optPhi[4][13][12], optPsi[4][13][12];

// The arrays below are for all FIVE high probability chain topologies.

int bestTopologyPosition[MAX_STRANDS][MAXTOP], bestTopologyUp[MAX_STRANDS][MAXTOP],
   bestM[MAXTOP], knL[9][9][9][9][5];
float bestTopologyProbability[MAXTOP];

int PpTable[6][10] =
{ {0, 1, 2, 3, 4, 0, 0, 0, 0, 0},
  {0, 1, 2, 3, 4, 5, 0, 0, 0, 0},
  {0, 1, 2, 3, 4, 5, 6, 0, 0, 0},
  {0, 1, 2, 3, 3, 4, 5, 6, 0, 0},
  {0, 1, 2, 3, 3, 3, 4, 5, 6, 0},
  {0, 1, 2, 3, 3, 3, 3, 4, 5, 6} };

int JTable[6][10] =
{ {0, 1, 2, 3, 4, 0, 0, 0, 0, 0},
  {0, 1, 2, 3, 4, 5, 0, 0, 0, 0},
  {0, 1, 1, 2, 2, 3, 3, 0, 0, 0},
  {0, 1, 1, 1, 2, 2, 3, 3, 0, 0},
  {0, 1, 1, 1, 2, 2, 2, 3, 3, 0},
  {0, 1, 1, 1, 2, 2, 2, 3, 3, 3} };

// P2[dir][helical][ln]
float P2[2][2][2] = 
{ { {0.01, 0.27}, {0.01, 0.13} },
  { {0.99, 0.73}, {0.99, 0.87} } };

// P3[config][helical][ln]
float P3[12][2][4] =
{ { {.0043, .0056, .0051, .0491}, {.0043, .0058, .0051, .0416} },
  { {.0043, .0056, .0829, .0803}, {.0043, .0058, .0830, .0681} },
  { {.8970, .4014, .2761, .1621}, {.8970, .6107, .4220, .2517} },
  { {.0043, .2622, .0051, .0285}, {.0043, .0423, .0051, .0242} },
  { {.0043, .0056, .0051, .0190}, {.0043, .0058, .0051, .0161} },
  { {.0364, .0115, .5472, .2822}, {.0364, .0118, .4011, .2394} },
  { {.0043, .0056, .0481, .0315}, {.0043, .0058, .0481, .0267} },
  { {.0043, .0056, .0051, .0142}, {.0043, .0058, .0051, .0121} },
  { {.0043, .0056, .0051, .1144}, {.0043, .0058, .0051, .0121} },
  { {.0043, .0056, .0051, .0348}, {.0043, .0058, .0051, .0295} },
  { {.0043, .0270, .0051, .0315}, {.0043, .0279, .0051, .0267} },
  { {.0279, .2587, .0103, .1525}, {.0279, .2668, .0103, .2517} } };

// Permute3[12][3] is the permutations in figure 9.4 of Ruczinski's thesis

int Permute3[12][3] = {
{0, 1, 2}, {0, 1, 2}, {0, 1, 2}, {0, 1, 2},
{0, 2, 1}, {0, 2, 1}, {0, 2, 1}, {0, 2, 1},
{1, 0, 2}, {1, 0, 2}, {1, 0, 2}, {1, 0, 2} };

// Dir3[12][3] gives the directions, with up = 1, and down = 0,
// in left to right order in the sheet, rather that in order along the strand.

int Dir3[12][3] = {
{0, 0, 0}, {0, 0, 1}, {0, 1, 0}, {0, 1, 1},
{0, 0, 0}, {0, 1, 0}, {0, 0, 1}, {0, 1, 1},
{0, 0, 0}, {0, 0, 1}, {1, 0, 0}, {1, 0, 1} };

/* To encode figure 9.9 of Ruczinski's thesis, CaseNum[H][ln] is the number of
   cases in each column, Permute4[H][ln][*][4] is the permutation shown, and
   Dir4 [H][ln][*] gives the up/down directions for the strands. Probility4
   gives the corresponding probabilities.                                     */

int CaseNum[2][8] = { {1, 4, 4, 2, 3, 2, 5, 4}, {1, 2, 3, 2, 3, 3, 3, 2} };

int Permute4[2][8][5][4] = {
{ { {0, 1, 2, 3}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0} },
  { {1, 2, 3, 0}, {0, 1, 2, 3}, {0, 1, 2, 3}, {1, 2, 3, 0}, {0, 0, 0, 0} },
  { {0, 1, 3, 2}, {1, 0, 2, 3}, {0, 1, 2, 3}, {1, 0, 3, 2}, {0, 0, 0, 0} },
  { {1, 0, 2, 3}, {0, 1, 3, 2}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0} },
  { {0, 3, 2, 1}, {0, 3, 2, 1}, {0, 1, 2, 3}, {0, 0, 0, 0}, {0, 0, 0, 0} },
  { {1, 3, 2, 0}, {0, 2, 3, 1}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0} },
  { {1, 0, 2, 3}, {0, 1, 3, 2}, {0, 1, 3, 2}, {1, 0, 2, 3}, {0, 3, 2, 1} },
  { {1, 0, 2, 3}, {1, 3, 2, 0}, {1, 2, 3, 0}, {0, 1, 3, 2}, {0, 0, 0, 0} } },
{ { {0, 1, 2, 3}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0} },
  { {0, 1, 2, 3}, {1, 2, 3, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0} },
  { {1, 0, 2, 3}, {0, 1, 3, 2}, {0, 1, 2, 3}, {0, 0, 0, 0}, {0, 0, 0, 0} },
  { {1, 0, 2, 3}, {0, 1, 3, 2}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0} },
  { {0, 1, 2, 3}, {0, 3, 2, 1}, {0, 3, 2, 1}, {0, 0, 0, 0}, {0, 0, 0, 0} },
  { {0, 2, 3, 1}, {1, 3, 2, 0}, {0, 3, 2, 1}, {0, 0, 0, 0}, {0, 0, 0, 0} },
  { {0, 1, 3, 2}, {0, 3, 2, 1}, {1, 0, 2, 3}, {0, 0, 0, 0}, {0, 0, 0, 0} },
  { {0, 2, 3, 1}, {0, 1, 3, 2}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0} } } };

int Dir4[2][8][5][4] = {
{ { {0, 1, 0, 1}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0} },
  { {0, 0, 1, 0}, {0, 1, 0, 1}, {0, 1, 0, 1}, {1, 0, 1, 0}, {0, 0, 0, 0} },
  { {0, 1, 0, 1}, {1, 0, 1, 0}, {0, 1, 0, 1}, {1, 0, 0, 1}, {0, 0, 0, 0} },
  { {1, 0, 1, 0}, {0, 1, 0, 1}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0} },
  { {0, 0, 1, 0}, {0, 1, 0, 1}, {0, 1, 0, 1}, {0, 0, 0, 0}, {0, 0, 0, 0} },
  { {1, 0, 1, 0}, {0, 1, 0, 1}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0} },
  { {0, 0, 1, 0}, {0, 1, 0, 1}, {0, 0, 1, 0}, {1, 0, 1, 0}, {0, 0, 1, 0} },
  { {0, 0, 0, 0}, {1, 0, 1, 0}, {0, 0, 0, 0}, {0, 1, 0, 1}, {0, 0, 0, 0} } },
{ { {0, 1, 0, 1}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0} },
  { {0, 1, 0, 1}, {1, 0, 1, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0} },
  { {1, 0, 1, 0}, {0, 1, 0, 1}, {0, 1, 0, 1}, {0, 0, 0, 0}, {0, 0, 0, 0} }, 
  { {1, 0, 1, 0}, {0, 1, 0, 1}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0} },
  { {0, 1, 0, 1}, {0, 1, 0, 1}, {0, 0, 1, 0}, {0, 0, 0, 0}, {0, 0, 0, 0} },
  { {0, 1, 0, 1}, {1, 0, 1, 0}, {0, 1, 0, 1}, {0, 0, 0, 0}, {0, 0, 0, 0} },
  { {0, 1, 0, 1}, {0, 0, 1, 0}, {1, 0, 1, 0}, {0, 0, 0, 0}, {0, 0, 0, 0} },
  { {0, 1, 0, 1}, {0, 1, 0, 1}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0} } } };

float Probability4[2][8][5] = {
{ {.85, 0., 0., 0., 0.},
  {.27, .21, .21, .6, 0.},
  {.51, .18, .14, .08, 0.},
  {.22, .17, 0., 0., 0.},
  {.36, .18, .09, 0., 0.},
  {.38, .24, 0., 0., 0.},
  {.28, .12, .10, .09, .05},
  {.36, .08, .07, .07, 0.} },
{ {.85, 0., 0., 0., 0.},
  {.44, .28, 0., 0., 0.},
  {.49, .28, .13, 0., 0.},
  {.38, .13, 0., 0., 0.},
  {.46, .15, .08, 0., 0.},
  {.27, .18, .16, 0., 0.},
  {.40, .24, .07, 0., 0.},
  {.62, .05, 0., 0., 0.} } };
  
// P(F | n, h) = FnH[n-5][h][F], where F is first position, and H is helical
float FnH[6][2][5] = 
{ { {.370, .340, .290, .000, .000}, {.570, .330, .100, .000, .000} },
  { {.380, .240, .380, .000, .000}, {.570, .190, .240, .000, .000} },
  { {.375, .125, .375, .125, .000}, {.375, .125, .375, .125, .000} },
  { {.400, .167, .167, .267, .000}, {.400, .167, .167, .267, .000} },
  { {.250, .125, .250, .125, .250}, {.250, .125, .250, .125, .250} },
  { {.400, .111, .111, .111, .267}, {.400, .111, .111, .111, .267} } };

// float pParPair[2] = {0.51, 0.24};  // from Ingo Ruczinski's thesis
// float pParPair[2] = {0.221, 0.084};

// float pJump[2][2] = {{0.25, 0.54}, {0.18, 0.28}};

//  The following are from my recomputation of the mean for the
//  binomial distribution.

float pParPair[6][2] = { {0.163399, 0.051020}, {0.141791, 0.031646},
   {0.352941, 0.094828}, {0.252874, 0.084967}, {0.121212, 0.138889},
   {0.270833, 0.111111} };

float pJump[6][2]    = { {0.161585, 0.106599}, {0.095238, 0.131098},
   {0.273148, 0.195833}, {0.295833, 0.200647}, {0.102564, 0.261111},
   {0.222222, 0.297619} };
  
int pairwisePotential1[20][20] =
{-29,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 -14,-18,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 -10,-15,-48,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  -4,-24,-29,-43,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  27,-25,-31,-45,-48,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  -9,-16,-31,-28, -5,-50,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 -21,-18,  0,-10,-34,-27,-11,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 -34, -1, 18,-18,-28, 16,-30,-53,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  25, -2, -2,-32, 21,-36,  1,-73,-75,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 -42,  8,  8, 36,-16,-28, 69,-74, 27,-177, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   6, 28, 76, 30, 99, 65, -2, 70,-78, 31,-78,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   4, 38, 18, 30, 57, 15, -3, 44,  0, 12, 21,-68,  0,  0,  0,  0,  0,  0,  0,  0,
  28,  6, 19, 57, 34, 25, 23, 74, 43, 28,  4,-23,-58,  0,  0,  0,  0,  0,  0,  0,
  49, -4, 48, 25,145, 12,-14, 46,-52,  7, 59,-21, -6,-45,  0,  0,  0,  0,  0,  0,
  54, 35, 41, 35, 44, -4, -6, -9,  7, 39, 73, 19,-31, 20,-17,  0,  0,  0,  0,  0,
  -9, 44, 37, 10, 24, 25, 33,-34,107,-45,-21,-13,-22,-56, 28,-15,  0,  0,  0,  0,
  56, 28, 53, 37,  0, 75,  0,  2, 44, 68, 26, -5,-26,-27,  5, 57, 21,  0,  0,  0,
  40, 59, 43, 37,  5, 31,  3,-20, 53, 92, 34, 24,-31,  0,-56,-11, 58, -3,  0,  0,
 -26, 24, 51, 80, 26, 33, 61, 74, 21, 53, 87, -3, 32,-43, -3,-61,-43,-79, 11,  0,
  21, 53, 37, 51, 53, 38, 25,137, 44, 17, 41, 10,-27, 76,-20,-14,-112,-85,86, 58
};

int pairwisePotential2[20][20] =
{-33,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   1,-34,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   7,-23,-26,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,-13, -8, -3,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   8,-13,-16,-20,-28,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  15,  7,-10,-20,-14,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  30,-13, -1, -6, -4, -1,-20,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  10, -5, 10,  4,-20,  7,-17, 31,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  55,-15, -1, -7, -4, 13,-12,-18,-30,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  -6, 59, 14, 31, 22,-13,-50, -7, -8,-102, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   7, 35, 35, 31, 42, 33,  8,-11,-25, 53,127,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  -3,  3,-12,-29,  9,-26,-19, -6,-11,-30,101, 62,  0,  0,  0,  0,  0,  0,  0,  0,
   4, -7,-17,-24, -4,-19,-15, -5,-14,-16, 95, 51, 60,  0,  0,  0,  0,  0,  0,  0,
 -10,  7,  0, 13, 10,-29, 30, 90, 37,-40, 52, 73, 53, 91,  0,  0,  0,  0,  0,  0,
  -6,104,  6,-23, -1,-24,-25,-57, 38,  5, 88, 63, 23, 83,  9,  0,  0,  0,  0,  0,
  13, -3, -7, 41,  5,-37,  2, 28,-50, 25, -6, 31, 14,-11, 94,-22,  0,  0,  0,  0,
  24,  2,-11,-13, -8,  6, -9,-33,  9, 50, 59, 80, 43,127, 50, 65, 65,  0,  0,  0,
  21,-23, -7, -4, -5,-20, -9, -4, 20,-43,  1, 48, 34, 35, 24, 24, 46, 30,  0,  0,
  18, 29, -5, -6, -1, -1, 22, 49,-11,-25,241, 41, 66, 79, 64, -1, 57,141,147,  0,
  19,  7,-13,-32,-24,-12, 37, 11,-17,-18,103, 64, 68, 73, 55, -1, 14, 42, 79, 57
};

int pairwisePotential3[20][20] =
{-22,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 -18,-26,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  12,-34,-27,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 -11,-13,-24,-42,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  20,-21,-20,-26,-43,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 -23,-38,-24,-43,-27,-10,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 -23,-37,-11,-12, -3, -6, 35,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   4, 47,  1,-29,-13,-14,-64,-93,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 -17,-52,-19, -4,  4,-37,-28, 99,-109, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  -3, 40, -3, -5, 18,-26, -8,  6,  5,-91,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  34, 49, 52, 24, 48, 40, 50, 40,113,-14, 94,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   7,  5,  8, 16, 44, 17, 24, 20, -7, 50, 43,-43,  0,  0,  0,  0,  0,  0,  0,  0,
  37, 37, -1, 39,  7, 31, 37, 31, 28, 32, 15,-30,-57,  0,  0,  0,  0,  0,  0,  0,
  13, 13, 25, 27, 41,126, 11, 28,  4, 18,180,  9,-13, 58,  0,  0,  0,  0,  0,  0,
   0, 27, 21, 25, 31, 37, 49, 42, 52,101,-26,-50, -3, 32,-24,  0,  0,  0,  0,  0,
  23,-44, 17,  0, 25, -7,-14, 46, 49,-22, 59,-31, 28,  7, 39, 36,  0,  0,  0,  0,
  34, 36,  6, 17, 13, 42, 33, 13, 27, 25,  0, 13, -9, 17, 39,-37, 61,  0,  0,  0,
  -5, 46,  5, 19, 54, 43,-42, 50,  3, 11,114, 20, 17, -7, 35,-41, 23, -3,  0,  0,
  14, 35, 43, 19, 20, 38, 19, 16, 66, 64, 29, 13,  8,-24,  9, -6,-24,-49, 23,  0,
  20, 25, 13, 21, 31, 20,-18, 23, 10, 87, 52,  1,  2, -1, 67,-34,-56,-51, 12, 35
};

int KreylosToZhu[23] = 
{-1, 1, 17, 13, 18, 9, 14, 19, 0, 15, 4, 3, 16, 8, -1, 5, 10, 11, 12, 7, 6, -1, 2};

int comparePosition(const void *v1, const void *v2) {
   int i=*((int*)v1);
   int j=*((int*)v2);
   return(i-j);
   }

float dot(Vector A, Vector B) {
   return (A[0]*B[0] + A[1]*B[1] + A[2]*B[2]);
   }

double binomialDistribution(float p, int i, int n) {
   double v = 1.;
   double op = 1. - p;
   int j, k;

   if(i < 0 || i > n) return 0.0;

   for(j = 0; j < i; ++j) {
      k = j + 1;
      v = (n - j)*p*v/(float)k;
      }
   for(j = i; j < n; ++j)
      v *= op;
   return v;
   }
   
void printStructure(const Protein* protein) {
   const Protein::Residue* oldPtr = NULL;
   int thisAlpha, thisBeta, structurePrint = 0;
   bool isBeta = false, isAlpha = false, firstBeta = false;
   int structureIndex = 0, thisStructure, thisCoilPiece, thisAlphaPiece;
   int totalAlpha = 0, totalBeta = 0, firstResidueIndex, atomcount;
   int i, j, k, ib, s0, s1, s2, arraysize, readsize, residueIndex = 0;
   const Protein::SecondaryStructure* currentSecondaryStructure=0;
   int betaCount, totalResidues, firstCoreBeta, lastCoreBeta;
   
   betaCount = 0;
   totalResidues = 0;
   thisBeta = -1;
   firstCoreBeta = -1;
   lastCoreBeta = -1;
   atomcount = -1;

   for(Protein::ConstAtomIterator aIt=protein->atomsBegin();aIt!=protein->atomsEnd();++aIt)
     	{
	++atomcount;
   	const Protein::Residue* rPtr=aIt->getResidue();
   	if(rPtr->getSecondaryStructure()!=currentSecondaryStructure)
     	   {
	   thisStructure = structureIndex;
	   ++structureIndex;
      	   switch(rPtr->getSecondaryStructure()->getStructureType()) {

      		case Protein::SecondaryStructure::ALPHA_HELIX:
      		isBeta = false;
		isAlpha = true;
		thisAlpha = thisStructure;
      		break;

      		case Protein::SecondaryStructure::BETA_STRAND:
      		thisBeta = betaCount;
      		++betaCount;
	        printf("\n");
      		isBeta = true;
      		firstBeta = true;
		isAlpha = false;
      		break;

      		case Protein::SecondaryStructure::COIL:
      		isAlpha = false;
      		isBeta = false;
      		}
      	   currentSecondaryStructure=rPtr->getSecondaryStructure();
           }
        if(rPtr != oldPtr) {
	   if(0) printf("%d %x %3s %d\n",
	      residueIndex, rPtr, rPtr->getPdbResidueName(),
	      rPtr->getSecondaryStructure()->getStructureType());
	   ++residueIndex;
	   if( isBeta) {
	      printf("Beta  %3d %3d %4d %3s %d\n", totalResidues, thisBeta, thisStructure,
	         rPtr->getPdbResidueName(),  rPtr->getType() );
	      ++totalBeta;
	      }
	   if(isAlpha) {
	      if(0) printf("Alpha %3d %3d %4d %3s %d\n", totalResidues, thisAlpha, thisStructure,
	         rPtr->getPdbResidueName(),  rPtr->getType() );
	      ++totalAlpha;
	      }
	   if(oldPtr != NULL) ++totalResidues;
	   oldPtr = rPtr;
	   }
	}
   }

bool initBuild(const Protein* protein) {

   const Protein::Residue* oldPtr = NULL;
   int thisAlpha, thisBeta, structurePrint = 0;
   bool isBeta = false, isAlpha = false, firstBeta = false;
   int structureIndex = 0, thisStructure, thisCoilPiece, thisAlphaPiece;
   int totalAlpha = 0, totalBeta = 0, firstResidueIndex, atomcount;
   int i, j, k, ib, s0, s1, s2, arraysize, readsize;
   FILE *fp, *fp2;
   char line[134];

   interact = configFile->retrieveValue<int,ValueCoder<int> >("/BuildBeta/interact",0 );
   test_zip = configFile->retrieveValue<int,ValueCoder<int> >("/BuildBeta/test_zip",0);
   enough_topologies = configFile->retrieveValue<int,ValueCoder<int> >("/BuildBeta/enough_topologies",6);
   try_topologies = configFile->retrieveValue<int,ValueCoder<int> >("/BuildBeta/try_topologies",11);
   spacing = configFile->retrieveValue<float,ValueCoder<float> >("/BuildBeta/spacing", 6.);
   flatfrac = configFile->retrieveValue<float,ValueCoder<float> >("/BuildBeta/flatfrac",0.5 );
   strand_to_coil_penalty = configFile->retrieveValue<float,ValueCoder<float> >("/BuildBeta/strand_to_coil_penalty",0.);
   move_helices = configFile->retrieveValue<int,ValueCoder<int> >("/BuildBeta/move_helices",1 );
   offlineBuildBeta = configFile->retrieveValue<int,ValueCoder<int> >("/BuildBeta/offlineBuildBeta",0 );
   optimized_angles = configFile->retrieveValue<int,ValueCoder<int> >("/BuildBeta/optimized_angles",0 );
   flatten = configFile->retrieveValue<int,ValueCoder<int> >("/BuildBeta/flatten",1 );
   shorten = configFile->retrieveValue<int,ValueCoder<int> >("/BuildBeta/shorten",1 );
   printf("strand_to_coil_penalty %f flatfrac %f\n",
      strand_to_coil_penalty, flatfrac);
      
   flatPhi = flatfrac*flflatPhi + (1. - flatfrac)*raflatPhi;
   flatPsi = flatfrac*flflatPsi + (1. - flatfrac)*raflatPsi;
   
   fp = fopen("binaryPpJ.out", "r");
   if(structurePrint) fp2 = fopen("structure.out", "w");
   arraysize = 6*7*4*2*2*6;
   readsize = fread(Pcount, sizeof(float), arraysize, fp);
   if(0) printf("readsize %d arraysize %d\n", readsize, arraysize);
   fclose(fp);
   ProteinState *state = curProtein();
   firstResidueIndex = state->protein->getResidueIndexRange().first;
   printf("firstResidueIndex %d\n", firstResidueIndex);

   fp = fopen("Alanine_Optimize_Angles", "r");
   for (i = 0; i < 4; ++i)
      for (j = 4; j <= 12; ++j)	{
         fgets(line,sizeof(line),fp);
	 sscanf(&line[18], "%d", &k);
	 if(k != i+1) {
	    printf("bad case type in file Alanine_Optimize_Angles %d %d %d\n",
	       i, j, k);
	    printf("%s", line);
	    exit(-1);
	    }
	 for(k = 0; k < 5; ++k)                 // skip lines
	    fgets(line,sizeof(line),fp);
	 for(k = 0; k < j; ++k) {
	    fgets(line,sizeof(line),fp);
	    sscanf(line,"%f %f", &optPhi[i][j][k], &optPsi[i][j][k]);
	    }
	 fgets(line,sizeof(line),fp);           // skip one line
	 }

   for(i = 0; i < 20; ++i)
      for(j = i+1; j < 20; ++j) {
         pairwisePotential1[i][j] = pairwisePotential1[j][i];
         pairwisePotential2[i][j] = pairwisePotential2[j][i];
         pairwisePotential3[i][j] = pairwisePotential3[j][i];
	 }
   
   /* Start checking for secondary structure boundaries: */

   const Protein::SecondaryStructure* currentSecondaryStructure=0;
   betaCount = 0;
   totalResidues = 0;
   thisBeta = -1;
   firstCoreBeta = -1;
   lastCoreBeta = -1;
   atomcount = -1;

   for(Protein::ConstAtomIterator aIt=protein->atomsBegin();aIt!=protein->atomsEnd();++aIt)
     	{
	++atomcount;
   	const Protein::Residue* rPtr=aIt->getResidue();
   	if(rPtr->getSecondaryStructure()!=currentSecondaryStructure)
     	   {
	   thisStructure = structureIndex;
	   ++structureIndex;
      	   switch(rPtr->getSecondaryStructure()->getStructureType()) {

      		case Protein::SecondaryStructure::ALPHA_HELIX:
      		isBeta = false;
		isAlpha = true;
		thisAlpha = thisStructure;
		alphaBegin[thisAlpha] = totalResidues;
		coreAlpha[thisAlpha] = is_core[totalResidues + firstResidueIndex];
		if(thisBeta >= 0) {
		   thisAlphaPiece = nAlphaPieces[thisBeta];
		   ++nAlphaPieces[thisBeta];
		   alphaPiece[thisBeta][thisAlphaPiece] = thisStructure;
		   if(thisAlphaPiece == 0 && 
		      nAlphaPieces[thisBeta] == nCoilPieces[thisBeta])
		      firstCoil[thisBeta] = 1;
		   }
      		break;

      		case Protein::SecondaryStructure::BETA_STRAND:
      		thisBeta = betaCount;
		coilLength[thisBeta] = 0;
		betaLength[thisBeta] = 0;
		nCoilPieces[thisBeta] = 0;
		nAlphaPieces[thisBeta] = 0;
		firstCoil[thisBeta] = 0;
		betaPiece[thisBeta] = thisStructure;
		betaStart[thisBeta] = totalResidues;
		coreBeta[thisBeta] = is_core[totalResidues + firstResidueIndex+1];
		printf("thisBeta %d is_core[%d] = %d\n", thisBeta,
		   firstResidueIndex + totalResidues + 1,
		   is_core[totalResidues + firstResidueIndex + 1]);
		if(coreBeta[thisBeta] && firstCoreBeta < 0) 
		   firstCoreBeta = thisBeta;
		if(coreBeta[thisBeta]) lastCoreBeta = thisBeta;
		if(thisBeta > 0) { // set lastCoil for previous strand
		   ib = thisBeta - 1;
		   if( (firstCoil[ib] == 1 &&
		         nCoilPieces[ib] != nAlphaPieces[ib] + 1) ||
	               (firstCoil[ib] == 0 &&
		         nCoilPieces[ib] != nAlphaPieces[ib]) )
		      lastCoil[ib] = 0;
		   else
		      lastCoil[ib] = 1;
		   }
      		++betaCount;
	        printf("\n");
      		isBeta = true;
      		firstBeta = true;
		isAlpha = false;
      		break;

      		case Protein::SecondaryStructure::COIL:
      		isAlpha = false;
      		isBeta = false;
		if(thisBeta >= 0) {
		   thisCoilPiece = nCoilPieces[thisBeta];
		   coilPiece[thisBeta][thisCoilPiece] = thisStructure;
		   coreCoil[thisBeta][thisCoilPiece] = is_core[totalResidues + firstResidueIndex];
		   ++nCoilPieces[thisBeta];
		   }
      		break;
      		}
      	   currentSecondaryStructure=rPtr->getSecondaryStructure();
           }
        if(rPtr != oldPtr) {
	   if( isBeta) {
	      printf("Beta  %3d %3d %4d %3s %d\n", totalResidues, thisBeta, thisStructure,
	         rPtr->getPdbResidueName(),  rPtr->getType() );
	      ++betaLength[thisBeta];
	      ++totalBeta;
	      if(structurePrint) fputc('E',fp2);
	      }
	   else if(firstBeta) {
	      ++coilLength[thisBeta];
	      if(0) printf("thisBeta %d coilLength %d isAlpha %d\n",
	         thisBeta, coilLength[thisBeta], isAlpha);
	      }
	   if(isAlpha) {
	      if(0) printf("Alpha %3d %3d %4d %3s %d\n", totalResidues, thisAlpha, thisStructure,
	         rPtr->getPdbResidueName(),  rPtr->getType() );
	      ++totalAlpha;
	      alphaEnd[thisAlpha] = totalResidues;  // keep updating it
	      if(structurePrint) fputc('H',fp2);
	      }
	   if(!isAlpha && !isBeta && structurePrint)
	      fputc('C',fp2);
	   if(oldPtr != NULL) ++totalResidues;
	   oldPtr = rPtr;
	   }
	
	}
   if(structurePrint) fclose(fp2);
   printf("betaCount %d totalResidues %d totalAlpha %d totalBeta %d\n",
      betaCount, totalResidues, totalAlpha, totalBeta);
   if(totalAlpha/totalResidues >= .2) 
      helical = 1;
   else
      helical = 0;
   printf("helical %d\n", helical);

   for(int i = 0; i < betaCount - 1; ++i) {
      if (betaStart[i+1] - (betaStart[i] + betaLength[i]) > 10)
         isLong[i] = 1;
      else
         isLong[i] = 0;
      printf("i %d betaLength %d coilLength %d betaPiece %d betaStart %d isLong %d coreBeta %d\n",
         i, betaLength[i], coilLength[i], betaPiece[i], betaStart[i], isLong[i], coreBeta[i]);
      for(int j = 0; j < nCoilPieces[i]; ++j) {
         printf("   %d", coilPiece[i][j]);
	 if(j < nCoilPieces[i] - 1)
	    printf("  %d", alphaPiece[i][j]);
	 }
      printf("\n");
      }
    i =  betaCount - 1;
    printf("i %d betaLength %d coilLength %d betaPiece %d betaStart %d isLong %d\n",
         i, betaLength[i], coilLength[i], betaPiece[i], betaStart[i], isLong[i]);
   
//   Zhu = (int*) malloc(totalResidues*sizeof(int));
   Zhu = new int[ totalResidues*sizeof(int)];
   if(!Zhu)
      {
   	  msg.Warn(RUNID,"No enough memory for Build Beta.");
      exit(1);
      } 
   i = 0;
   oldPtr = NULL;
   for(Protein::ConstAtomIterator aIt=protein->atomsBegin();aIt!=protein->atomsEnd();++aIt)
     	{
   	const Protein::Residue* rPtr=aIt->getResidue();
	if(rPtr != oldPtr) {
	   oldPtr = rPtr;
	   Zhu[i] = KreylosToZhu[rPtr->getType()];
	   if(0 && Zhu[i] < 0) {
	      printf("bad residue type in InitBuild; i %d rPtr->getType() %d\n",
	         i, rPtr->getType());
	      }
	   ++i;
	   }
	}
   j = 1;
   k = 1;
   for(i = 0; i <= betaCount; ++i) {
      twoPower[i] = j;
      j *= 2;
      THRE_power[i] = k;
      k *= THRE;
      }
   return true;
   }
   
int findCaseBestFOUR() {
   int i, j, k, l, s, casec, tempc, caseCount, len0, len1, firstResidueIndex,
      mins, maxs, b0, e0, b1, e1, oldb1, olde1, k0, k1, p0, p1, n1, strand, sign,
      add, a, m, tempBegin[MAX_STRANDS], tempEnd[MAX_STRANDS], coilprint = 0,
      kzip, r, odd, succeeded;
   float e;
  
    ProteinState *state = curProtein();
    if ( !state ) return 1;
    firstResidueIndex = state->protein->getResidueIndexRange().first;

/*   First find best THRE shifts for each strand pair.
     Strand counts along the sheet from left to right,
     while i and j count along the backbone sequence.    */

   for(strand = 0; strand < betaCount - 1; ++strand) {
      i = positionInverse[strand];
      j = positionInverse[strand + 1];
      len0 = betaLength[i];
      len1 = betaLength[j];
      mins = 2 - len0;
      maxs = len1 - 2;
      for (k = 0; k < THRE; ++k)
         bestE[strand][k] = LARGE;
      if(0) printf("strand %d i %d j %d len0 %d len1 %d\n",
         strand, i, j, len0, len1);

//  s is the index displacement of the second strand from the first
//  both p0 and p1 count from the bottom of the strand as drawn in the sheet

      succeeded = 0;
      for(s = mins; s <= maxs; ++s) {
	 e = 0.;
	 if( s > 0 )
	    k0 = 0;
	 else 
	    k0 = -s;
	 if(len1 - s < len0)
	    k1 = len1 - s - 1;
	 else
	    k1 = len0 - 1;
	 kzip = (k0 + k1)/2;

//  Increment k1 to be the upper limit for strand iteration loop

	 k1 += 1;
	 for (k = k0; k < k1; ++k) {
	    if(up[strand])
	       p0 = betaStart[i] + k;
	    else
	       p0 = betaStart[i] + betaLength[i] - 1 - k;
	    if(up[strand + 1])
	       p1 = betaStart[j] + k + s;
	    else
	       p1 = betaStart[j] + betaLength[j] - 1 - (k + s);
	    e +=  pairwisePotential1[Zhu[p0]][Zhu[p1]];
	    if(0) printf("%d  ", pairwisePotential1[Zhu[p0]][Zhu[p1]]);

	    for (add = 1; add <= doTerms; ++add) {
	      for(sign = -1; sign <= 1; sign += 2) {
	        a = sign * add;
		n1 = k + a;
		if(n1 >= k0 && n1 < k1) {
	          if(up[strand + 1])
	             p1 = betaStart[j] + n1 + s;
	          else
	             p1 = betaStart[j] + betaLength[j] - 1 - (n1 + s);
		  if (add == 1) 
		     e +=  pairwisePotential2[Zhu[p0]][Zhu[p1]];
		  else
		     e +=  pairwisePotential3[Zhu[p0]][Zhu[p1]];
		     }
	          }
	       }
	     }
	 if(0) printf("s %2d  k0 %2d  k1 %2d  %2d   %d\n",
	    s, k0, k1, k1 - k0, e);
	 for(k = 0; k < THRE; ++k) {
	  if(e < bestE[strand][k]) {
	   if(test_zip && (i == j+1 || i == j-1))

// require structure to be constructable in both cases of odd,
// without using any strand shortening

	   for(odd = 0; odd < 2; ++odd) {
	    if(up[strand])
	       p0 = betaStart[i] + kzip;
	    else
	       p0 = betaStart[i] + betaLength[i] - 1 - kzip;
	    if(up[strand + 1])
	       p1 = betaStart[j] + kzip + s;
	    else
	       p1 = betaStart[j] + betaLength[j] - 1 - (kzip + s);
	    Protein::StructureSelector movingStrand = state->protein->pickStructure(betaPiece[j]);
	    state->interactor->selectStructure(movingStrand);
            state->interactor->clearCoilRegions();
	    if(i < j)
               l = i;
	    else
	       l = j;
            for(m = 0; m < nCoilPieces[l]; ++m)
		if(!coreCoil[l][m]) {
	          state->interactor->toggleCoil(state->protein->pickStructure(coilPiece[l][m]));
	          if(coilprint) printf(" %d", coilPiece[l][m]);
	          }
	    if(up[strand] == up[strand + 1]) {
	      if(odd == 0) {
		if(0) printf("altZipParallel  ");
	        r = altZipParallel(state->protein->pickResidue(p1), state->protein->pickResidue(p0), plane[strand], center[strand]);
		if(r != 0) goto test_zipped;
		if(p0 - 1 - firstResidueIndex >= betaStart[i] &&
		   p1 - 1 - firstResidueIndex >= betaStart[j]) {
		   r=zipParallel(state->protein->pickResidue(p1-1), state->protein->pickResidue(p0-1), plane[strand], center[strand]);
		   if(r != 0) goto test_zipped;
		   if(p0+1-firstResidueIndex < betaStart[i]+betaLength[i] &&
		      p1+1-firstResidueIndex < betaStart[i]+betaLength[j]) {
		      r=zipParallel(state->protein->pickResidue(p1+1), state->protein->pickResidue(p0+1), plane[strand], center[strand]);
		      if (r != 0) goto test_zipped;
		      goto test_quit;
		      }
		   }
		}
	      else {
		if(0) printf("ZipParallel  ");
	        r = zipParallel(state->protein->pickResidue(p1), state->protein->pickResidue(p0), plane[strand], center[strand]);
		if(r != 0) goto test_zipped;
		if(p0 - 1 - firstResidueIndex >= betaStart[i] &&
		   p1 - 1 - firstResidueIndex >= betaStart[j]) {
		   r=altZipParallel(state->protein->pickResidue(p1-1), state->protein->pickResidue(p0-1), plane[strand], center[strand]);
		   if(r != 0) goto test_zipped;
		   if(p0+1-firstResidueIndex < betaStart[i]+betaLength[i] &&
		      p1+1-firstResidueIndex < betaStart[i]+betaLength[j]) {
		      r=altZipParallel(state->protein->pickResidue(p1+1), state->protein->pickResidue(p0+1), plane[strand], center[strand]);
		      if(r != 0) goto test_zipped;
		      goto test_quit;
		      }
		   }
		}
	      }
	    else {

// Figure 8A of Zhu and Braun shows anti-parallel strands matched with one flipped.

	      if(odd == 0) {
		if(0) printf("ZipAntiParallel p0 %d p1 %d kzip %d s %d k %d\n",
		   p0, p1, kzip, s, k);
	        r = zipAntiParallel(state->protein->pickResidue(p1), state->protein->pickResidue(p0), plane[strand], center[strand]);
		if(r != 0) goto test_zipped;
		if(p0-1-firstResidueIndex >= betaStart[i] &&
		   p1+1-firstResidueIndex < betaStart[i]+betaLength[j]) {
		   r = altZipAntiParallel(state->protein->pickResidue(p1+1), state->protein->pickResidue(p0-1), plane[strand], center[strand]);
		   if(r != 0) goto test_zipped;
		   if(p0+1-firstResidueIndex < betaStart[i]+betaLength[i] &&
		      p1-1-firstResidueIndex >= betaStart[j]) {
		      r = altZipAntiParallel(state->protein->pickResidue(p1-1), state->protein->pickResidue(p0+1), plane[strand], center[strand]);
		      if(r != 0) goto test_quit;
		      goto test_quit;
		      }
		   }
		}
	      else {
		if(0) printf("altZipAntiParallel  ");
	        r = altZipAntiParallel(state->protein->pickResidue(p1),state->protein->pickResidue(p0), plane[strand], center[strand]);
		if(r != 0) goto test_zipped;
		if(p0-1-firstResidueIndex >= betaStart[i] &&
		   p1+1-firstResidueIndex < betaStart[i]+betaLength[j]) {
		   r = zipAntiParallel(state->protein->pickResidue(p1+1), state->protein->pickResidue(p0-1), plane[strand], center[strand]);
		   if(r != 0) goto test_zipped;
		   if(p0+1-firstResidueIndex < betaStart[i]+betaLength[i] &&
		      p1-1-firstResidueIndex >= betaStart[j]) {
		      r = zipAntiParallel(state->protein->pickResidue(p1-1), state->protein->pickResidue(p0+1), plane[strand], center[strand]);
		      if(r != 0) goto test_zipped;
		      goto test_quit;
		      }
		   }
		}
	      }
test_zipped:
            if(lastIKResidual >= .04) goto test_quit;
	    }
	       succeeded = 1;
	       for(l = THRE - 1; l > k; --l) {
		  bestE[strand][l] = bestE[strand][l - 1];
		  bestStart[strand][l] =  bestStart[strand][l - 1];
		  }
	       bestE[strand][k] = e;
	       bestStart[strand][k] = s;
	       goto next_s;
test_quit: ;
	       }
	    }
next_s: ;
         }
	 if(succeeded == 0) 
	    printf("No successful test zip for strand %d\n", strand);
      }
// now pick the best FOUR summed energies over all strands;
 
   caseCount = THRE_power[betaCount - 1];
   for(i = 0; i < FOUR + 1; ++i)
      bestTotalE[i] = LARGE;
   for (casec = 0; casec < caseCount; ++casec) {
      tempc = casec;
      if(0) printf("casec %d ", casec);
      for(k = 0; k < betaCount - 1; ++k) {
         choice[k] = tempc % THRE;
	 tempc /= THRE;
	 if(0) printf("choice %d s %d ", choice[k], bestStart[k][choice[k]]);
	 }
      if(0) printf("\n");
      e = 0;
      for(strand = 0; strand < betaCount - 1; ++strand) {
	 if(bestE[strand][choice[strand]] == LARGE) goto quitcase;
         i = positionInverse[strand];
         j = positionInverse[strand + 1];
         len0 = betaLength[i];
         len1 = betaLength[j];
	 e += bestE[strand][choice[strand]];
	 s = bestStart[strand][choice[strand]];
	 tempStart[strand] = s;
	 if( s > 0 )
	    k0 = 0;
	 else 
	    k0 = -s;
	 if(len1 - s < len0)
	    k1 = len1 - s - 1;
	 else
	    k1 = len0 - 1;

//  At this point k1 is the actual last residue, not the upper limit of the loop.
//  Compute possible shortening of beta strands in favor of lengthened coils.
	 
	 oldb1 = b1;
	 olde1 = e1;
	 if(up[strand]) {
	    b0 = betaStart[i] + k0;
	    e0 = betaStart[i] + k1;
	    }
	 else {
	    b0 = betaStart[i] + betaLength[i] - 1 - k1;
	    e0 = betaStart[i] + betaLength[i] - 1 - k0;
	    }
	 if(b0 < betaStart[i])
	    printf("error in shortening b0 computation; i %d b0 %d %d\n",
	       i, b0, betaStart[i]);
	 if(e0 > betaStart[i] + betaLength[i] - 1)
	    printf("error in shortening e0 computation; i %d e0 %d %d\n",
	       i, e0, betaStart[i] + betaLength[i] - 1);
	 if(up[strand + 1]) {
	    b1 = betaStart[j] + k0 + s;
	    e1 = betaStart[j] + k1 + s;
	    }
	 else {
	    b1 = betaStart[j] + betaLength[j] - 1 - k1 - s;
	    e1 = betaStart[j] + betaLength[j] - 1 - k0 - s;
	    }
	 if(b1 < betaStart[j])
	    printf("error in shortening b1 computation; j %d b1 %d %d\n",
	       j, b1, betaStart[j]);
	 if(e1 > betaStart[j] + betaLength[j] - 1)
	    printf("error in shortening e1 computation; j %d e1 %d %d\n",
	       j, e1, betaStart[j] + betaLength[j] - 1);
	 if(coilprint) printf("k0 %d k1 %d s %d b0 %d e0 %d b1 %d e1 %d ",
	    k0, k1, s, b0, e0, b1, e1);
	 if(strand > 0) {
	    if(coilprint) printf("oldb1 %d olde1 %d ", oldb1, olde1);
	    if(oldb1 < betaStart[i])
	       printf("error in shortening computation; i %d oldb1 %d %d\n",
	          i, oldb1, betaStart[i]);
	    if(olde1 > betaStart[i] + betaLength[i] - 1)
	       printf("error in shortening computation; i %d olde1 %d %d\n",
	          i, olde1, betaStart[i] + betaLength[i] - 1);
	    if(oldb1 < b0) b0 = oldb1;
	    if(olde1 > e0) e0 = olde1;
	    }
	 tempBegin[strand] = b0;
	 tempEnd[strand] = e0;
	 if(coilprint) printf("strand %d i %d begin %d end %d\n", strand, i,
	    tempBegin[strand], tempEnd[strand]);
	 if (i > 0 && lastCoil[i - 1] == 1)
	    for (k = betaStart[i]; k < b0; ++k) 
	       e += strand_to_coil_penalty*conf[k + firstResidueIndex];
	 if (i < betaCount - 1 && firstCoil[i] == 1)
	    for (k = betaStart[i] + betaLength[i] - 1; k > e0; --k) 
	       e += strand_to_coil_penalty*conf[k + firstResidueIndex];
	 }
      
// Add penalty for last strand; b1 and e1 defined by last iteration above.

      strand = betaCount - 1;
      tempBegin[strand] = b1;
      tempEnd[strand] = e1;
      i = positionInverse[strand];
      if(coilprint) printf("strand %d begin %d end %d\n", strand,
         tempBegin[strand], tempEnd[strand]);
      if (i > 0 && lastCoil[i - 1] == 1)
         for (k = betaStart[i]; k < b1; ++k) 
            e += strand_to_coil_penalty*conf[k + firstResidueIndex];
      if (i < betaCount - 1 && firstCoil[i] == 1)
         for (k = betaStart[i] + betaLength[i] - 1; k > e1; --k) 
            e += strand_to_coil_penalty*conf[k + firstResidueIndex];
      
      if(0) printf("tempc %d choice %d %d %d %d  starts %2d %2d %2d  e %d\n", casec,
         choice[0], choice[1], choice[2], choice[3], bestStart[0][choice[0]], 
	 bestStart[1][choice[1]], bestStart[2][choice[2]], e);

// Insert in list of FOUR if energy is better than those so far.
// Actually, create list of FOUR + 1, so that the one causing too many
// repeats can later be removed.

      inserted = 0;
      for(k = 0; k < FOUR + 1; ++k) {
         if(e < bestTotalE[k]) {
	    if(0){
	      for (strand = 0; strand < betaCount; ++strand)
	       printf("strand %d i %d %d tempBegin %d end %d betaStart %d\n",
	       strand, i, positionInverse[strand], tempBegin[strand],
	       tempEnd[strand], betaStart[positionInverse[strand]]);
	      printf("\n");
	      }
	    inserted = 1;
	    for(l = FOUR; l > k; --l) {
	       bestTotalE[l] = bestTotalE[l-1];
	       if(0) printf("bestTotalE[%d] = %f\n", l, bestTotalE[l]);
	          bestTotalStart[strand][l] = bestTotalStart[strand][l - 1];
               for (strand = 0; strand < betaCount; ++strand) {
	          bestBegin[strand][l] = bestBegin[strand][l-1];
	          bestEnd[strand][l]   = bestEnd[strand][l-1];
	          }
	       }
            bestTotalE[k] = e;
	    if(0) printf("bestTotalE[%d] = %f\n", k, bestTotalE[k]);
            for (strand = 0; strand < betaCount - 1; ++strand)
               bestTotalStart[strand][k] = tempStart[strand];
	    if (0 || coilprint) printf("Begin End pairs for k %d casec %d: ",
	       k, casec);
            for (strand = 0; strand < betaCount; ++strand) {
	       bestBegin[strand][k] = tempBegin[strand];
	       bestEnd[strand][k]   = tempEnd[strand];
	       if (0 || coilprint) printf("s %d %d %d  ",
	          bestTotalStart[strand][k],
		  tempBegin[strand], tempEnd[strand]);
	       }
	    if (0 || coilprint) printf("\n");
	    break;
	    }
	 }
      if(inserted) {
         
// Count repetitions of strand starts that are the same as in the new one
// Then, if they exceed TWO, remove the one of the cases with these repetition
// that has the highest energy.

         for (strand = 0; strand < betaCount - 1; ++strand) {
	    repeat[strand] = 0;
	    for (k = 0; k < FOUR + 1; ++k)
	       if(bestTotalStart[strand][k] == tempStart[strand]) ++repeat[strand];
	    }
	 for (k = 0; k < FOUR + 1; ++k) {
	    found = 1;
	    for (strand = 0; strand < betaCount - 1; ++strand)
	       if (repeat[strand] > 2 &&
	          bestTotalStart[strand][k] != tempStart[strand]) found = 0;
	    if(found == 1) remove = k;
	    }
	 for(l = remove; l < FOUR; ++l) {
	    bestTotalE[l] = bestTotalE[l + 1];
	    for (strand = 0; strand < betaCount - 1; ++strand)
	       bestTotalStart[strand][l] = bestTotalStart[strand][l + 1];
            for (strand = 0; strand < betaCount; ++strand) {
	       bestBegin[strand][l] = bestBegin[strand][l+1];
	       bestEnd[strand][l]   = bestEnd[strand][l+1];
	       }
	    }
	 }
quitcase: ;	    
      }
      if(0) for (k = 0; k < FOUR; ++k) {
	 printf("ic %d\n", k);
         for(strand = 0; strand < betaCount; ++strand) {
	    i = positionInverse[strand];
            printf("strand %d i %d bestBegin %d bestEnd %d betaStart %d End %d\n",
	       strand, i, bestBegin[strand][k], bestEnd[strand][k],
	       betaStart[i], betaStart[i] + betaLength[i] - 1);
	    }
	 }
   }

void BuildBeta() {
   int i, j, l, m, n, L, firstResidueIndex, k, k0, k1, len0, len1, s, p0, p1, jt,
      ib, ic, M, ntopology, strand, h, ln, twop, od, odd, nextBeta, coilPrint = 0, 
      caseCount, casec, tempc, b0, b1, e0, e1, le1, succeeded = 0, gaveup = 0,
      half, temp, kmin, vmin, J, Js, Pp, Ps, Ns, pu, pl, ju, jl, knl, count, r,
      maxknL, maxcount, numResidues, up0, up1, up2, savep1, shortcount, np, nq,
      below[MAX_STRANDS], firstpos, environment, add, stop, cp, cq, thisAlpha,
      bres, cres, fixp = 0, good, sptr, iptr, coresheetbonds, badcore,
      free_edges, core_parallel[MAX_STRANDS][2], pib, skippedCase = 0,
      zipProline, topologies, alignments, foundThisTopology, lengthened,
      longcount, firstResiduePlus, bresp, cresp, printStruct = 0, shpr = 0;
   float val, den, pFirst, pPpJ, p, sumF, dd;
   double v, sum, pj, pjump, pparpair, ppp, maxppp = 0.;
   char *protein_name, pn[120], digits[30], outputfilename[140], *cPtr, ch[2];
   bool par0, par1;
   MD::Point averageCenter;
   MD::Point CC[60];
   MD::Vector averagePlane, strand_direction[MAX_STRANDS];
   MD::Protein::Dipole carboxyl, carboxyl0, carboxyl1, amide0, amide1;
   MD::Protein::Residue* residue;
   MD::Protein::Residue* residue0;
   MD::Protein::Residue* residue1;
   MD::Protein::Residue* residue2;
   MD::Protein::Residue* residue3;
   MD::Protein::Residue* lresidue1;
   MD::Protein::Residue* lresidue2;
   MD::Protein::Residue* lresidue3;
   
   ProteinState *state = curProtein();
   if ( !state ) return;

   gaveup = 0;
   skippedCase = 0;
   succeeded = 0;
   zipProline = 0;

   protein_name = &pn[0];
   strcpy(protein_name, inputfilename);
   sptr = 0;
   for(cPtr=protein_name, iptr = 0;*cPtr!='\0';++cPtr, ++iptr) {
      if(*cPtr=='/') sptr = iptr + 1;
      if(*cPtr=='.') break;
      }
   *cPtr = '\0';  // truncate string from first '.';
   protein_name = &pn[sptr];
   printf("protein_name %s\n", protein_name);
   firstResidueIndex = state->protein->getResidueIndexRange().first;
   if (strcmp(state->protein->atomsBegin()->getResidue()->getPdbResidueName(), 
      "ACE") != 0) 
       firstResiduePlus = firstResidueIndex;
   else
       firstResiduePlus = firstResidueIndex + 1;

//     firstResiduePlus is one more to skip meaningless ACE group in count;

   printf("firstResidueIndex %d firstResiduePlus %d\n",
       firstResidueIndex, firstResiduePlus);
   
   if(has_core) {
      badcore = 0;

//  find core beta sheet hydrogen bonds

      coresheetbonds = 0;
      for(ib = 0; ib < betaCount; ++ib)
         for(j = 0; j < 2; ++j)
	    core_edge[ib][j] = -1;
      for(ib = 0; ib < betaCount; ++ib)
       if(coreBeta[ib]) {
         for(bres = betaStart[ib]; bres < betaStart[ib] + betaLength[ib]; ++bres) {
	    bresp = bres + firstResiduePlus;
	    residue0 = state->protein->pickResidue(bresp);
	    carboxyl0 = residue0->getCarboxyl();
	    amide0 = residue0->getAmide();
	    for(ic = ib+1; ic < betaCount; ++ic)
	     if(coreBeta[ic])
	       for(cres = betaStart[ic]; cres < betaStart[ic] + betaLength[ic]; ++cres) {
		  cresp = cres + firstResiduePlus;
	          residue1 = state->protein->pickResidue(cresp);
	          carboxyl1 = residue1->getCarboxyl();
	          amide1 = residue1->getAmide();
		  if( (amide0.isValid()&&carboxyl1.isValid()&&
		       formHydrogenBond( amide0, carboxyl1 ) ) ||
		      (amide1.isValid()&&carboxyl0.isValid()&&
		       formHydrogenBond( amide1, carboxyl0 ) ) ) {
		     if(1) printf(
		        "bresp %d  cresp %d ib %d ic %d core_edges %d %d\n",
		        bresp, cresp, ib, ic, core_edge[ib][bresp % 2],
		        core_edge[ic][cresp % 2]);
		     ++coresheetbonds;
		     if(amide0.isValid()&&carboxyl1.isValid()&&
		        formHydrogenBond( amide0, carboxyl1 ) )
			printf("Found Hydrogen Bond A ib %d %d ic %d %d\n  NH %f %f %f \n  CO %f %f %F\n",
			   ib, coreBeta[ib], ic, coreBeta[ic],
			   amide0.getMinorAtom()->getPosition()[0], 
			   amide0.getMinorAtom()->getPosition()[1], 
			   amide0.getMinorAtom()->getPosition()[2], 
			   carboxyl1.getMinorAtom()->getPosition()[0], 
			   carboxyl1.getMinorAtom()->getPosition()[1], 
			   carboxyl1.getMinorAtom()->getPosition()[2]); 
		     if(amide1.isValid()&&carboxyl0.isValid()&&
		        formHydrogenBond( amide1, carboxyl0 ) )
			printf("Found Hydrogen Bond B ib %d %d ic %d %d\n  NH %f %f %f \n  CO %f %f %F\n",
			   ib, coreBeta[ib], ic, coreBeta[ic],
			   amide1.getMinorAtom()->getPosition()[0], 
			   amide1.getMinorAtom()->getPosition()[1], 
			   amide1.getMinorAtom()->getPosition()[2], 
			   carboxyl0.getMinorAtom()->getPosition()[0], 
			   carboxyl0.getMinorAtom()->getPosition()[1], 
			   carboxyl0.getMinorAtom()->getPosition()[2]); 
		     if(core_edge[ib][bresp % 2] < 0) {
		        core_edge[ib][bresp % 2] = ic;
			printf("core_edge[%d][%d] set to %d\n",
			   ib, bresp % 2, ic);
			}
		     else if(core_edge[ib][bresp % 2] != ic) {
		        printf("Inconsistent beta sheet bonding in core\n");
			badcore = 1;
			}
		     if(core_edge[ic][cresp % 2] < 0) {
		        core_edge[ic][cresp % 2] = ib;
			printf("core_edge[%d][%d] set to %d\n",
			   ic, cresp % 2, ib);
			}
		     else if(core_edge[ic][cresp % 2] != ib) {
		        printf("Inconsistent beta sheet bonding in core\n");
			badcore = 1;
			}
		     }
	          }
	    }
	 bres = betaStart[ib];
	 cres = betaStart[ib] + betaLength[ib];
	 residue0 = state->protein->pickResidue( bres + firstResiduePlus );
	 residue1 = state->protein->pickResidue( cres + firstResiduePlus );
	 strand_direction[ib] =
	    residue1->getCarboxyl().getMajorAtom()->getPosition() -
	    residue0->getCarboxyl().getMajorAtom()->getPosition();
	 }
      printf("coresheetbonds %d\n", coresheetbonds);
      free_edges = 0;
      for(ib = 0; ib < betaCount; ++ib)
       if(coreBeta[ib]) {
         for (k = 0; k < 2; ++k) {
            if (core_edge[ib][k] < 0) ++free_edges;
	    else {
	       ic = core_edge[ib][k];
	       dd = dot(strand_direction[ib], strand_direction[ic]);
	       if (fabs(dd) < 0.5) {
	          printf("Bad alignment of strands %d and %d\n", ib, ic);
		  exit(-1);
		  }
	       if (dd > 0) core_parallel[ib][k] = 1;
	       else core_parallel[ib][k] = 0;
	       printf("core_parallel[%d][%d] = %d\n",
	          ib, k, core_parallel[ib][k]);
	       }
	    }
         printf("core_edges for strand %d are %d and %d\n",
	   ib, core_edge[ib][0], core_edge[ib][1]);
         }
      if(free_edges != 2) {
         printf("Wrong number %d of free edges in BuildBeta.\n",
	    free_edges);
	 exit(-1);
	 }
      if(badcore) exit(-1);
      printf("End of core processing\n");
      }
   
   if(betaCount == 2) {
      ntopology = 2;
      for (i = 0; i < 2; ++i) {
	 bestTopologyUp[0][i] = 0;
         bestTopologyUp[1][i] = 1 - i; // since anti-parallel has higher probability
	 bestTopologyPosition[0][i] = 0;
	 bestTopologyPosition[1][i] = 1;
	 bestTopologyProbability[i] = P2[up[1]][helical][isLong[0]];
	 }
      }
   else if(betaCount == 3) { 
      ntopology = FIVE;
      ln = 0;
      twop = 1;
      for(i = betaCount - 2; i >= 0; --i) {
         ln += twop*isLong[i];
	 twop *= 2;
	 }
      for (i = 0; i < FIVE; ++i) 
         bestTopologyProbability[i] = 0.;
      for (i = 0; i < 12; ++i)
         for (j = 0; j < FIVE; ++j) 
	    if(P3[i][helical][ln] >= THRESHOLD &&
	       P3[i][helical][ln] > bestTopologyProbability[j]) {
	       for (k = FIVE - 1; k > j; --k) {
	          bestTopologyProbability[k] = bestTopologyProbability[k - 1];
		  bestM[k] = bestM[k - 1];
		  }
	       bestTopologyProbability[j] = P3[i][helical][ln];
	       bestM[j] = i;
	       break;
	       }
      for (j = 0; j < FIVE; ++j)
         for (i = 0; i < 3; ++i) {
	    M = bestM[j];
	    bestTopologyPosition[i][j] = Permute3[M][i];
	    bestTopologyUp[i][j] = Dir3[M][i];
	    }
      }
   else if(betaCount == 4) {
      ln = 0;
      twop = 1;
      for(i = betaCount - 2; i >= 0; --i) {
         ln += twop*isLong[i];
	 twop *= 2;
	 }
      ntopology = CaseNum[helical][ln];
      for (j = 0; j < ntopology; ++j) {
         bestTopologyProbability[j] = Probability4[helical][ln][j];
	 for (i =0; i < 4; ++i) {
	    bestTopologyPosition[i][j] = Permute4[helical][ln][j][i];
	    bestTopologyUp[i][j] = Dir4[helical][ln][j][i];
	    }
	 }
      }
   else if(betaCount <= 10) {

      ntopology = try_topologies;
      if(ntopology > MAXTOP) {
         printf("desired value of try_topologies %d > MAXTOP %d\n",
	    try_topologies, MAXTOP);
	 ntopology = MAXTOP;
	 }
      caseCount = twoPower[betaCount - 1];
      for (j = 0; j < ntopology; ++j)
         bestTopologyProbability[j] = 0.;
      up[0] = 1;
      half = (betaCount+1)/2;

//  Process permutations in lexicographic (or numerical ) order.
//  First generate counts knL

      for(i = 0; i < betaCount; ++i)
        for(j = 0; j < betaCount; ++j)
	   for(k = 0; k < betaCount; ++k)
	      for(l = 0; l < betaCount; ++l)
	         for (m = 0; m <= half; ++m)
		    knL[i][j][k][l][m] = 0;
      count = 0;
      for (i = 0; i < betaCount; ++i)
        position[i] = i;

permutationLoop0: ;
	if(position[0] >= half) goto skipP;
	if(betaCount%2 && position[0] == half-1 && position[1] >= half)
	   goto skipP;
	if(0) {
	  printf("permutation ");
	  for (i = 0; i < betaCount; ++i)
	     printf("%d ", position[i]);
	  printf("\n");
	  }
	for (i = 0; i < betaCount; ++i)
	  positionInverse[position[i]] = i;
	
        for (casec = 0; casec < caseCount; ++casec) {
           tempc = casec;
           for(k = 1; k < betaCount; ++k) {
             up[k] = tempc % 2;
             tempc /= 2;
	     }
	   L = 1;
           J = 0;
	   Js = 0;
	   Pp = 0;
	   Ps = 0;
	   Ns = 0;
	   for (i = 0; i < betaCount - 1; ++i) {
	     if(isLong[i] == 0) {
	        L = 0;
	        ++Ns;
		}
	     if(position[i+1] != position[i] - 1 &&
	        position[i+1] != position[i] + 1 ) {
	        ++J;
	        if(isLong[i] == 0) ++Js;
	        }
	     if(up[position[i+1]] == up[position[i]]) {
	        ++Pp;
	        if(isLong[i] == 0) ++Ps;
	        }
	     }
	   ++knL[Pp][Ps][J][Js][position[0]];
	   ++count;
	   if(0) printf("incremented knL[%d][%d][%d][%d][%d]",
	                    Pp, Ps, J ,Js, position[0]);
	   if(0) printf(" for position %d %d %d %d %d  up %d %d %d %d %d\n",
	      position[0], position[1], position[2], position[3], position[4],
	      up[0], up[1], up[2], up[3], up[4]);
	   }
skipP: ;
	for (j = betaCount; j > 0; --j) 
	  if (position[j-1] < position[j]) {
	    vmin = 100000;
	    for (k = j; k < betaCount; ++k) 
	       if(position[k] > position[j-1] && position[k] < vmin) {
	          kmin = k;
		  vmin = position[k];
		  }
	    if(vmin >= 100000) {
	       printf("problem with permutation generator\n");
	       exit(-1);
	       }
	    temp = position[kmin];
	    position[kmin] = position[j-1];
	    position[j-1] = temp;
	    qsort(&(position[j]), betaCount - j, sizeof(int), comparePosition);
	    goto permutationLoop0;
	    }
      printf("first pass count is %d\n", count);

      count = 0;
      sum = 0.;
      for (i = 0; i < betaCount; ++i)
        position[i] = i;
permutationLoop: ;
	if(position[0] >= half) goto skipPermutation;
	if(betaCount%2 && position[0] == half-1 && position[1] >= half)
	   goto skipPermutation;

// Make topology consistent with core region specification

	for (ib = 0; ib < betaCount; ++ib)
	  if(coreBeta[ib])
	    for(j = 0; j < 2; ++j) {
	      ic = core_edge[ib][j];
	      if (ic >= 0) 
	         if(position[ic] != position[ib] - 1 &&
		    position[ic] != position[ib] + 1 )
		       goto skipPermutation;
	       }
	if(0) {
	  printf("permutation ");
	  for (i = 0; i < betaCount; ++i)
	     printf("%d ", position[i]);
	  printf("\n");
	  }
	for (i = 0; i < betaCount; ++i)
	  positionInverse[position[i]] = i;
	
        for (casec = 0; casec < caseCount; ++casec) {
           tempc = casec;
           for(k = 1; k < betaCount; ++k) {
             up[k] = tempc % 2;
             tempc /= 2;
	     }
	   for (ib = 0; ib < betaCount; ++ib)
	     if(coreBeta[ib])
	       for(j = 0; j < 2; ++j) {
	         ic = core_edge[ib][j];
	         if (ic >= 0) {
		   pib = position[ib];
		   if(position[ic] == pib + 1) 
		     if((core_parallel[ib][j] && up[pib] != up[pib + 1]) ||
		       (!core_parallel[ib][j] && up[pib] == up[pib + 1]) )
		         goto skipUp;
		   }
	         }

	   L = 1;
           J = 0;
	   Js = 0;
	   Pp = 0;
	   Ps = 0;
	   Ns = 0;
	   for (i = 0; i < betaCount - 1; ++i) {
	     if(isLong[i] == 0) {
	        L = 0;
	        ++Ns;
		if(0) printf("i %d Ns %d\n", i, Ns);
		}
	     if(position[i+1] != position[i] - 1 &&
	        position[i+1] != position[i] + 1 ) {
	        ++J;
	        if(isLong[i] == 0) ++Js;
	        }
	     if(up[position[i+1]] == up[position[i]]) {
	        ++Pp;
	        if(isLong[i] == 0) ++Ps;
	        }
	     }

// get factor pFirst = P(F | n, h) from array
// P(F | n, h) = FnH[n-5][h][F], where F is first position, and H is helical

	   n = betaCount - 5;
           pFirst = FnH[n][helical][position[0]];
	   sumF = 0;
	   for(k = 0; k <= half; ++k)
	      sumF += FnH[n][helical][k];

// get factor pPpJ = P(Pp, J | n, H, L, F) from arrray
// float Pcount[6][7][4][2][2][6];
// Pcount[n][Pp][J][H][L][F] is count for Pp, J given n, H, L, F

	   pPpJ = Pcount[n][PpTable[n][Pp]][JTable[n][J]][helical][L][position[0]];
	   pl = Pp + Ns - (betaCount - 1);
	   if (pl < 0) pl = 0;
	   pu = Pp;
	   if (Ns < Pp) pu = Ns;

// double binomialDistribution(float p, int i, int n) 

	   pparpair = binomialDistribution(pParPair[n][helical], Ps - pl, pu - pl);
	   jl = J + Ns - (betaCount - 1);
	   if (jl < 0) jl = 0;
	   ju = J;
	   if (Ns < J) ju = Ns;
/*
	   if(betaCount < 7)
	      pj = pJump[0][helical];
	   else
	      pj = pJump[1][helical];
*/
	   pj = pJump[n][helical];
	   pjump =  binomialDistribution(pj, Js - jl,  ju - jl);

	   ppp = double(pFirst * pPpJ) * pparpair * pjump
	       / (double)knL[Pp][Ps][J][Js][position[0]];

	   if(ppp > 0 && ppp == bestTopologyProbability[ntopology - 1] &&
	      ppp == bestTopologyProbability[0])
	      if(ntopology < MAXTOP){
	         bestTopologyProbability[ntopology] = ppp;
		 for(strand = 0; strand < betaCount; ++strand) {
		    bestTopologyPosition[strand][ntopology] = position[strand];
		    bestTopologyUp[strand][ntopology] = up[strand];
		    }
	         ++ntopology;
	         }
	      else {
	         printf("terminated search because MAXTOP of %d reached.\n",
		    ntopology);
		 printf("increase MAXTOP to include more equal probabilities.\n");
		 goto donePermutationLoop; // early termination
		 }
	   else
              for (j = 0; j < ntopology; ++j)  {
                 if(ppp > bestTopologyProbability[j]) {
	           for (k = ntopology - 1; k > j; --k) {
	              bestTopologyProbability[k] = bestTopologyProbability[k - 1];
		      for(strand = 0; strand < betaCount; ++strand) {
		        bestTopologyPosition[strand][k] = 
			   bestTopologyPosition[strand][k - 1];
			bestTopologyUp[strand][k] = bestTopologyUp[strand][k - 1];
			}
		      }
		    for(strand = 0; strand < betaCount; ++strand) {
		      bestTopologyPosition[strand][j] = position[strand];
		      bestTopologyUp[strand][j] = up[strand];
		      }
		    bestTopologyProbability[j] = ppp;
	            break;
		  }
	       }
	   if(0 || knL[Pp][Ps][J][Js][position[0]] == 0) {
	      if(0) printf("knL[%d][%d][%d][%d][%d] = %2d",
	         Pp, Ps, J ,Js, position[0],
		 knL[Pp][Ps][J][Js][position[0]]);
	      if(0) printf(" for position %d %d %d %d %d %d  up %d %d %d %d %d %d ppp %f\n",
	         position[0], position[1], position[2], position[3], position[4],
	         position[5], up[0], up[1], up[2], up[3], up[4], up[5] ,ppp);
	      if(0) printf("  Pp %d J %d Ns %d", Pp, J, Ns);
	      if(0) printf ("  pl %d pu %d Ps %d pparpair %5f jl %d ju %d Js %d pjump %5f",
	         pl, pu, Ps, pparpair, jl, ju, Js, pjump);
	      }
	   sum += ppp;
	   if (ppp > maxppp) {
	      maxppp = ppp; 
	      maxcount = 1;
	      maxknL = knL[Pp][Ps][J][Js][position[0]];
	      }
	   else if (ppp == maxppp)
	      ++maxcount;
	   ++count;

skipUp: ;
           }
skipPermutation: ;
	for (j = betaCount; j > 0; --j) 
	  if (position[j-1] < position[j]) {
	    vmin = 100000;
	    for (k = j; k < betaCount; ++k) 
	       if(position[k] > position[j-1] && position[k] < vmin) {
	          kmin = k;
		  vmin = position[k];
		  }
	    if(vmin >= 100000) {
	       printf("problem with permutation generator\n");
	       exit(-1);
	       }
	    temp = position[kmin];
	    position[kmin] = position[j-1];
	    position[j-1] = temp;
	    qsort(&(position[j]), betaCount - j, sizeof(int), comparePosition);
	    goto permutationLoop;
            }
donePermutationLoop: ;
      printf("sum %g  count %d maxppp %g, maxcount %d maxknL %d\n",
        sum, count, maxppp, maxcount, maxknL);
	for(j = 0; j < ntopology; ++j)
	  printf("j %d position %d %d %d %d %d  up %d %d %d %d %d ppp %f\n", 
	     j, bestTopologyPosition[0][j], bestTopologyPosition[1][j],
	     bestTopologyPosition[2][j], bestTopologyPosition[3][j],
	     bestTopologyPosition[4][j],
	     bestTopologyUp[0][j], bestTopologyUp[1][j], bestTopologyUp[2][j],
	     bestTopologyUp[3][j], bestTopologyUp[4][j], bestTopologyProbability[j]);
      } 
   else {
      printf("Can currently handle only up to 10 beta strands.\n");
      exit(-1);
      }
   printf("Number of topology cases: %d\n", ntopology);

// Flatten strands at the beginning if shortening is not done per case.

   if(shorten == 0 && optimized_angles == 0 && flatten) {
        for(i = 0; i < betaCount; ++i) {
	    Protein::StructureSelector flatteningStrand = state->protein->pickStructure(betaPiece[i]);
	    state->interactor->selectStructure(flatteningStrand);
            state->interactor->clearCoilRegions();
            numResidues = state->interactor->getStructure().getNumResidues();
	    if(0) printf("flattening %d residues in strand %d\n", numResidues, i);
            if(numResidues > 2 && state->interactor->isBetaStrand())
                {
                MD::Scalar* phis=new MD::Scalar[numResidues];
                MD::Scalar* psis=new MD::Scalar[numResidues];
		if(optimized_angles == 0 || numResidues < 5)
                   for (j =0;j<numResidues;++j)
                      {
                      phis[j]=Math::rad(flatPhi);
                      psis[j]=Math::rad(flatPsi);
                      }
                undoBuffer.startInteraction(state->interactor->getStructure(),state->interactor->getUpdateDirection());
                state->interactor->setDihedralAngles(phis,psis);
                delete[] phis;
                delete[] psis;
                undoBuffer.finishInteraction();
                state->proteinRenderer->updateProtein();
                if(state->energyCalculator!=0)
                        state->energyCalculator->updateProtein();
                }
	   }
	// state->proteinRenderer->updateStructureFlags();
        }


// odd is 0 if  hydrogen bond sites on strand 0 at zip position p0 point to the right

   topologies = 0;
   for (jt = 0; jt < ntopology; ++jt)
    {
    foundThisTopology = 0;
    for (strand = 0; strand < betaCount; ++strand) {
	position[strand] = bestTopologyPosition[strand][jt];
	up[strand] = bestTopologyUp[strand][jt];
        k = position[strand];
        positionInverse[k] = strand;
        }
    findCaseBestFOUR();
    for (od = 0; od < 2; ++od) {
      alignments = 0;
      for (ic = 0; ic < FOUR; ++ic) 
        if(bestTotalE[ic] < LARGE) {
        if(0) printf("ic %d  bestStart %2d %2d %2d e %f\n", ic,
           bestTotalStart[0][ic], bestTotalStart[1][ic],
	   bestTotalStart[2][1], bestTotalE[ic]);

        odd = od;
        printf("jt %d  od %d  ic %d\n", jt, od, ic);
        printf("succeeded %d  gave up %d  skippedCase %d  zipProline %d\n",
           succeeded, gaveup, skippedCase, zipProline);
        if(1) {
	   printf("position ");
           for (strand = 0; strand < betaCount; ++strand)
	      printf(" %d", position[strand]);
	   printf("\npositionInverse ");
           for (strand = 0; strand < betaCount; ++strand)
	      printf(" %d", positionInverse[strand]);
	   printf("\nup ");
           for (strand = 0; strand < betaCount; ++strand)
	      printf(" %d", up[strand]);
	   printf("\n");
	   }
   
         for(strand = 0; strand < betaCount; ++strand)
            placed[strand] = 0;
         placed[positionInverse[0]] = 1;
	 shortcount = 0;
	 longcount = 0;
	 if(1 || optimized_angles) {

// Compute the below[i] needed for finding the correct entry in
// the optimized angle files. The "1 ||" was added because in the case
// where a core exists,the tests to decide wheter to skip an alignment
// are still necessary.

	  odd = od;
          for(strand = 0; strand < betaCount - 1; ++strand) {
            i = positionInverse[strand];
            j = positionInverse[strand + 1];
            len0 = betaLength[i];
            len1 = betaLength[j];
	    s = bestTotalStart[strand][ic];
	    if( s > 0 )
	       k0 = 0;
	    else 
	       k0 = -s;
	    if(len1 - s < len0)
	       k1 = len1 - s;
	    else
	       k1 = len0;
	    k = (k0 + k1)/2;

// both p0 and p1 count from the bottom of the strand as drawn in the sheet

	    if(up[strand])
	       p0 = betaStart[i] + k;
	    else
	       p0 = betaStart[i] + betaLength[i] - 1 - k;
	    if(up[strand + 1])
	       p1 = betaStart[j] + k + s;
	    else
	       p1 = betaStart[j] + betaLength[j] - 1 - (k + s);

// skip case if adjacent to core region and free side of core is not
//  the one being hydrogen bonded to.

	    p0 += firstResiduePlus;
	    p1 += firstResiduePlus;
	    if(0) printf ("i coreBeta[%d] %d core_edge %d %d index %d %d\n",
	       i, coreBeta[i], core_edge[i][0], core_edge[i][1], p0, p0%2);
	    if(0) printf ("j coreBeta[%d] %d core_edge %d %d index %d %d\n\n",
	       j, coreBeta[j], core_edge[j][0], core_edge[j][1],
	       p1 + odd + (up[strand] == up[strand + 1]),
	       (p1 + odd + (up[strand] == up[strand + 1]))%2);
	    if( coreBeta[j] && !coreBeta[i] && core_edge[j]
//	      [(p1 + odd + (up[strand] == up[strand + 1]))%2] >= 0)
	      [(p1 + odd + (up[strand] == up[strand + 1]))%2] < 0)
	       {
	       ++skippedCase;
	       goto skipCase;
	       }
//  	    if( coreBeta[i] && !coreBeta[j] && core_edge[i][p0%2] >= 0)
            if( coreBeta[i] && !coreBeta[j] && core_edge[i][p0%2] < 0) 
	       {
	       ++skippedCase;
	       goto skipCase;
	       }

	    if (strand > 0) {

// odd is 0 if zipping hydrogen bond sites on strand 0 at p0 point to the right
// if difference between zipping residues is odd, new odd must be switched
// if previous zipping was antiparallel, new odd must be switched

	       if( (p0 + savep1)%2) odd = 1 - odd;
	       if(up[strand - 1] != up[strand]) odd = 1 - odd;
	       }
	    savep1 = p1;
	    if( coreBeta[i] && coreBeta[j] )  break;

	    if(shorten)
	       firstpos = bestBegin[strand][ic];
	    else
	       firstpos = betaStart[i];

// below is 1 if first hydrogen bond sites on strand 0 point to the right;
// otherwise -1

	    below[i] = 1 - 2*( (odd + p0 - firstpos)%2);
	    }
	  }
	 if(shpr) printf("before shortening\n");
	 if(printStruct) printStructure(state->protein);
	    
// now shorten strands starting from coil ends inwards

          if(shorten) {
	   if(shpr) {
	      printf("position ");
              for (strand = 0; strand < betaCount; ++strand)
	         printf(" %d", position[strand]);
	      printf("\npositionInverse ");
              for (strand = 0; strand < betaCount; ++strand)
	         printf(" %d", positionInverse[strand]);
	         printf("\n");
	      }
	   for (strand = 0; strand < betaCount; ++strand) {
	    i = positionInverse[strand];
	    if(coreBeta[i]) break;
	    b0 = bestBegin[strand][ic];
	    e0 = bestEnd[strand][ic];
	    if(b0 < betaStart[i])
	       printf("bad bestBegin %d betaStart %d\n",
	          b0, betaStart[i]);
	    if(e0 > betaStart[i] + betaLength[i] - 1)
	       printf("bad bestEnd %d betaEnd %d\n",
	          e0, betaStart[i] + betaLength[i] - 1);
	    add = 0;

// allow extra space for diagonal hydrogen bonds on parallel strands

	    if (strand > 0)
	       if(up[strand] == up[strand - 1]) add = 1;
	    if (strand < betaCount - 1)
	       if(up[strand] == up[strand + 1]) add = 1;
	    if(shpr) printf("i %d begin %d end %d betaStart %d betaEnd %d add %d\n",
	       i, b0 - add, e0 + add, betaStart[i],
	       betaStart[i] + betaLength[i] - 1, add);
	    if (i > 0 && lastCoil[i - 1] == 1)
	     for (j = betaStart[i]; j < b0 - add; ++j) {
	       ++shortcount;
	       if(shorten > 1)
		  for (m = -1; m <= 1; ++m)
	          std::cout << state->protein->pickResidue(j + m + firstResiduePlus)
		       << "  "
	               << (state->protein->pickResidue(j + m + firstResiduePlus))->getSecondaryStructure()->getStructureType()
		       << "\n";
	       state->protein->changeResidueStructureType(
	          state->protein->pickResidue(j + firstResiduePlus),
	          Protein::SecondaryStructure::COIL);
	       if(shorten > 1) printf("changed residue %d to COIL\n",
	          j + firstResidueIndex);
	       if(shorten > 1) {
		  for (m = -1; m <= 1; ++m)
	          std::cout << state->protein->pickResidue(j + m + firstResiduePlus)
		       << "  "
	               << (state->protein->pickResidue(j + m + firstResiduePlus))->getSecondaryStructure()->getStructureType()
		       << "\n";
		  std::cout << "\n";
		  }
	       } 
	    if (i < betaCount - 1 && firstCoil[i] == 1)
	     for (j = betaStart[i] + betaLength[i] - 1; j > e0 + add; --j) {
	       ++shortcount;
	       if(shorten > 1)
		  for (m = -1; m <= 1; ++m)
	          std::cout << state->protein->pickResidue(j + m + firstResiduePlus)
		       << "  "
	               << (state->protein->pickResidue(j + m + firstResiduePlus))->getSecondaryStructure()->getStructureType()
		       << "\n";
	       state->protein->changeResidueStructureType(
	          state->protein->pickResidue(j + firstResiduePlus),
	          Protein::SecondaryStructure::COIL);
	       if(shorten > 1) printf("changed residue %d to COIL\n",
	          j + firstResidueIndex);
	       if(shorten > 1) {
		  for (m = -1; m <= 1; ++m)
	          std::cout << state->protein->pickResidue(j + m + firstResiduePlus)
		       << "  "
	               << (state->protein->pickResidue(j + m + firstResiduePlus))->getSecondaryStructure()->getStructureType()
		       << "\n";
		  std::cout << "\n";
		  }
	       } 
	    }
	   state->proteinRenderer->updateStructureFlags();
	   }
	 if(shpr) printf("after shortening\n");
	 if(printStruct) printStructure(state->protein);

//  flatten flattening strand, which is really strand i, for each i

	  if (flatten) {
	   for(i = 0; i < betaCount; ++i) 
	    if(!coreBeta[i]) {
	      Protein::StructureSelector flatteningStrand = state->protein->pickStructure(betaPiece[i]);
	      state->interactor->selectStructure(flatteningStrand);
              state->interactor->clearCoilRegions();
              numResidues = state->interactor->getStructure().getNumResidues();
	      if(0) printf("flattening %d residues in strand %d\n", numResidues, i);
              if(numResidues > 2 && state->interactor->isBetaStrand())
                {
                MD::Scalar* phis=new MD::Scalar[numResidues];
                MD::Scalar* psis=new MD::Scalar[numResidues];
		if(optimized_angles == 0 || numResidues < 5)
                   for(j=0;j<numResidues;++j)
                      {
                      phis[j]=Math::rad(flatPhi);
                      psis[j]=Math::rad(flatPsi);
                      }
		else {
		   up1 = up[position[i]];
		   if(position[i] > 0) 
		      up0 = up[position[i] + below[i]];
		   else
		      up0 = 1 - up1; // favor antiparallel
		   if(position[i] < betaCount - 1)
		      up2 = up[position[i] - below[i]];
		   else
		      up2 = 1 - up1; // favor antiparallel
		   par0 = (up0 == up1);
		   par1 = (up1 == up2);
		   environment = par0 + 2*par1;
                   for(j=0;j<numResidues;++j)
                      {
                      phis[j]= optPhi[environment][numResidues][j];
                      psis[j]= optPsi[environment][numResidues][j];
		      printf("%d %f %f\n", j, phis[j], psis[j]);
                      }
		   printf("used optimized angles on strand %d\n", i);
		   }
                undoBuffer.startInteraction(state->interactor->getStructure(),state->interactor->getUpdateDirection());
                state->interactor->setDihedralAngles(phis,psis);
                delete[] phis;
                delete[] psis;
                undoBuffer.finishInteraction();
                state->proteinRenderer->updateProtein();
                if(state->energyCalculator!=0)
                        state->energyCalculator->updateProtein();
                }
	    }
	   state->proteinRenderer->updateStructureFlags();
	   }

// do zipping

         odd = od;
         for(strand = 0; strand < betaCount - 1; ++strand) {
            i = positionInverse[strand];
            j = positionInverse[strand + 1];
	    if(coreBeta[i] && coreBeta[j]) {
	       placed[j] = 1;
	       printf("position %d strand %d in core so zipping skipped\n",
	          strand + 1, j);
	       continue;
	       }
            len0 = betaLength[i];
            len1 = betaLength[j];
	    s = bestTotalStart[strand][ic];
	    if( s > 0 )
	       k0 = 0;
	    else 

	       k0 = -s;
      if(coilPrint > 1) {
         int oldb1, olde1, b2, e2;
	 if(len1 - s < len0)
	    k1 = len1 - s - 1;
	 else
	    k1 = len0 - 1;

//  At this point k1 is the actual last residue, not the upper limit of the loop.
//  Compute possible shortening of beta strands in favor of lengthened coils.
	 
	 oldb1 = b1;
	 olde1 = e1;
	 if(up[strand]) {
	    b0 = betaStart[i] + k0;
	    e0 = betaStart[i] + k1;
	    }
	 else {
	    b0 = betaStart[i] + betaLength[i] - 1 - k1;
	    e0 = betaStart[i] + betaLength[i] - 1 - k0;
	    }
	 if(up[strand + 1]) {
	    b1 = betaStart[j] + k0 + s;
	    e1 = betaStart[j] + k1 + s;
	    }
	 else {
	    b1 = betaStart[j] + betaLength[j] - 1 - k1 - s;
	    e1 = betaStart[j] + betaLength[j] - 1 - k0 - s;
	    }
	 if(0) printf("extra k0 %d k1 %d s %d b0 %d e0 %d b1 %d e1 %d\n",
	    k0, k1, s, b0, e0, b1, e1);
	 if(strand > 0) {
	    b2 = b0;
	    e2 = e0;
	    if(oldb1 < b0) b2 = oldb1;
	    if(olde1 > e0) e2 = olde1;
	    if(0) printf("extra strand %d i %d begin %d %d %d end %d %d %d\n",
	       strand, i, b0, oldb1, b2, e0, olde1, e2);
	    }
         }
	    if(len1 - s < len0)
	       k1 = len1 - s;
	    else
	       k1 = len0;
	    k = (k0 + k1)/2;

// both p0 and p1 count from the bottom of the strand as drawn in the sheet

	    if(up[strand])
	       p0 = betaStart[i] + k;
	    else
	       p0 = betaStart[i] + betaLength[i] - 1 - k;
	    if(up[strand + 1])
	       p1 = betaStart[j] + k + s;
	    else
	       p1 = betaStart[j] + betaLength[j] - 1 - (k + s);
	    p0 += firstResiduePlus;
	    p1 += firstResiduePlus;
	    if (strand > 0) {

// odd is 0 if  hydrogen bond sites on strand 0 at p0 point to the right
// if difference between zipping residues is odd, new odd must be switched
// if previous zipping was antiparallel, new odd must be switched

	       if( (p0 + savep1)%2) odd = 1 - odd;
	       if(up[strand - 1] != up[strand]) odd = 1 - odd;
	       }
	    savep1 = p1;
	    Protein::StructureSelector movingStrand = state->protein->pickStructure(betaPiece[j]);
	    state->interactor->selectStructure(movingStrand);
            state->interactor->clearCoilRegions();
	    if(coilPrint) {
	       printf("placed ");
	       for(l = 0; l < betaCount; ++l)
	          printf("%d ", placed[l]);
	       }
	    if(coilPrint) printf("placing strand %d coilpieces: left ", j);
            l = j - 1;
	    found = 0;
	    for (m = 0; m < j; ++m)
	       found += placed[m];

// only toggle coils if there is an already placed strand before this one.

	    if(found > 0) while(1) {
	       if( l < 0 || placed[l + 1]) break;
               for(k = 0; k < nCoilPieces[l]; ++k)
		 if(!coreCoil[l][k]) {
	          state->interactor->toggleCoil(state->protein->pickStructure(coilPiece[l][k]));
	          if(coilPrint) printf(" %d", coilPiece[l][k]);
	          }
	         else if(coilPrint) printf(" %d", -coilPiece[l][k]);
	       --l;
	       }
	    l = j;
	    if(coilPrint) printf("  right ");
	    found = 0;
	    for (m = j + 1; m < betaCount; ++m)
	       found += placed[m];
	    if(found > 0) while(1) {
	       if(l == betaCount - 1 || placed[l]) break;
               for(k = 0; k < nCoilPieces[l]; ++k) 
		 if(!coreCoil[l][k]) {
	          state->interactor->toggleCoil(state->protein->pickStructure(coilPiece[l][k]));
	          if(coilPrint) printf(" %d", coilPiece[l][k]);
	          }
	         else if(coilPrint) printf(" %d", -coilPiece[l][k]);
	       ++l;
	       }
	    if(0 || coilPrint) printf("\n  p0 %d p1 %d  k %d s %d \n", p0, p1, k, s);
	    if(interact > 1 && (0 || gaveup == 12) ) {
		printf("before moving strand %d\n", j);
                printf("type r for very early return, any other character to continue \a");
                if(getchar() == 'r') {
		       state->proteinRenderer->updateStructureFlags();
	           return;
	           }
	        }
	    if(up[strand] == up[strand + 1]) {
	      if(odd == 0) {
		if(0) printf("altZipParallel  ");
	        r = altZipParallel(state->protein->pickResidue(p1), state->protein->pickResidue(p0), plane[strand], center[strand]);
		if(r != 0) goto zipped;
		if(p0 - 1 - firstResiduePlus >= betaStart[i] &&
		   p1 - 1 - firstResiduePlus >= betaStart[j]) {
		   r=zipParallel(state->protein->pickResidue(p1-1), state->protein->pickResidue(p0-1), plane[strand], center[strand]);
		   if(r != 0) goto zipped;
		   if(p0+1-firstResiduePlus < betaStart[i]+betaLength[i] &&
		      p1+1-firstResiduePlus < betaStart[i]+betaLength[j]) {
		      r=zipParallel(state->protein->pickResidue(p1+1), state->protein->pickResidue(p0+1), plane[strand], center[strand]);
		      if (r != 0) goto zipped;
		      goto quitProline;
		      }
		   }
		}
	      else {
		if(0) printf("ZipParallel  ");
	        r = zipParallel(state->protein->pickResidue(p1), state->protein->pickResidue(p0), plane[strand], center[strand]);
		if(r != 0) goto zipped;
		if(p0 - 1 - firstResiduePlus >= betaStart[i] &&
		   p1 - 1 - firstResiduePlus >= betaStart[j]) {
		   r=altZipParallel(state->protein->pickResidue(p1-1), state->protein->pickResidue(p0-1), plane[strand], center[strand]);
		   if(r != 0) goto zipped;
		   if(p0+1-firstResiduePlus < betaStart[i]+betaLength[i] &&
		      p1+1-firstResiduePlus < betaStart[i]+betaLength[j]) {
		      r=altZipParallel(state->protein->pickResidue(p1+1), state->protein->pickResidue(p0+1), plane[strand], center[strand]);
		      if(r != 0) goto zipped;
		      goto quitProline;
		      }
		   }
		}
	      }
	    else {

// Figure 8A of Zhu and Braun shows anti-parallel strands matched with one flipped.

	      if(odd == 0) {
		if(0) printf("ZipAntiParallel  ");
	        r = zipAntiParallel(state->protein->pickResidue(p1), state->protein->pickResidue(p0), plane[strand], center[strand]);
		if(r != 0) goto zipped;
		if(p0-1-firstResiduePlus >= betaStart[i] &&
		   p1+1-firstResiduePlus < betaStart[i]+betaLength[j]) {
		   r = altZipAntiParallel(state->protein->pickResidue(p1+1), state->protein->pickResidue(p0-1), plane[strand], center[strand]);
		   if(r != 0) goto zipped;
		   if(p0+1-firstResiduePlus < betaStart[i]+betaLength[i] &&
		      p1-1-firstResiduePlus >= betaStart[j]) {
		      r = altZipAntiParallel(state->protein->pickResidue(p1-1), state->protein->pickResidue(p0+1), plane[strand], center[strand]);
		      if(r != 0) goto quitProline;
		      goto quitProline;
		      }
		   }
		}
	      else {
		if(0) printf("altZipAntiParallel  ");
	        r = altZipAntiParallel(state->protein->pickResidue(p1),state->protein->pickResidue(p0), plane[strand], center[strand]);
		if(r != 0) goto zipped;
		if(p0-1-firstResiduePlus >= betaStart[i] &&
		   p1+1-firstResiduePlus < betaStart[i]+betaLength[j]) {
		   r = zipAntiParallel(state->protein->pickResidue(p1+1), state->protein->pickResidue(p0-1), plane[strand], center[strand]);
		   if(r != 0) goto zipped;
		   if(p0+1-firstResiduePlus < betaStart[i]+betaLength[i] &&
		      p1-1-firstResiduePlus >= betaStart[j]) {
		      r = zipAntiParallel(state->protein->pickResidue(p1-1), state->protein->pickResidue(p0+1), plane[strand], center[strand]);
		      if(r != 0) goto zipped;
		      goto quitProline;
		      }
		   }
		}
	      }
quitProline:
	    printf("Zip failed because of too many prolines\n");
	    ++zipProline;
	    goto giveUp;
zipped:
	    printf("IK error %g\n",lastIKResidual); 
	    placed[j] = 1;
	    if(up[strand]) 
	       for(i = 0; i < 3; ++i) {
	           plane[strand][i]  = - plane[strand][i];
		   center[strand][i] = - center[strand][i];
		   }
	    state->interactor->selectStructure(MD::Protein::StructureSelector());
	    renderWindow->centerView();

            if(lastIKResidual >= .04) {
               ++gaveup;
               printf("IK did not converge; residual %g shortened %d gaveup %d\n", 
	          lastIKResidual, shortcount, gaveup);
	       if(offlineBuildBeta == 0 && interact) {
	          fprintf(stderr, "before undoing shortening\a\n");
                  printf("type r for return, other character to continue ");
                  if(getchar() == 'r') {
		         state->proteinRenderer->updateStructureFlags();
	             return;
	             }
		  }
               goto giveUp;
               } 

            }
	 ++succeeded;
	  
// output new structure now; may be updated later if helices can be moved

	 strcpy(outputfilename, protein_name);
	 strcat(outputfilename, ".");
	 sprintf(digits, "%d", succeeded);
	 printf("wrote file %d ", succeeded);
	 strcat(outputfilename, digits);
	 strcat(outputfilename, ".up");
	 printf("up ");
	 for (k = 0; k < betaCount; ++k) {
	    sprintf(digits, "%d", up[k]);
	    printf("%d ", up[k]);
	    strcat(outputfilename, digits);
	    }
	 strcat(outputfilename, ".pos");
	 printf(" position ");
	 for (k = 0; k < betaCount; ++k) {
	    sprintf(digits, "%d", position[k]);
	    printf("%d ", position[k]);
	    positionInverse[position[k]] = k;
	    strcat(outputfilename, digits);
	    }
	 printf(" position inverse ");
	 for (k = 0; k < betaCount; ++k) {
	    printf("%d ", positionInverse[k]);
	    }
	 strcat(outputfilename, ".od");
	 sprintf(digits, "%d", od);
	 strcat(outputfilename, digits);
	 strcat(outputfilename, ".short");
	 sprintf(digits, "%d", shortcount);
	 strcat(outputfilename, digits);
	 strcat(outputfilename, ".IngoScore");
	 sprintf(digits, "%7f", bestTopologyProbability[jt]);
	 strcat(outputfilename, digits);
	 strcat(outputfilename, ".ZhuEnergy");
	 sprintf(digits, "%4.2f", bestTotalE[ic]);
	 strcat(outputfilename, digits);
	 strcat(outputfilename, ".pdb");
	 printf("\n");
	 fprintf(stderr, "writing file %s\n", outputfilename);
	 printf("writing file %s\n", outputfilename);
	 if(offlineBuildBeta == 0 && interact) {
	     fprintf(stderr, "input 'r' to return to interactive mode \a");
             if(getchar() == 'r') {
	         state->proteinRenderer->updateStructureFlags();
	            return;
	         }
	     }
	 fflush(NULL);
         writePdbFile(*state->protein, outputfilename);
	 if(printStruct) printStructure(state->protein);

	 good = 0;
	 for( ib = 0; ib < betaCount - 1; ++ib) 
	  if( nCoilPieces[ib] > 1 ) good = 1;

/* Now adjust any alpha helices between beta strands so that they are on the
   correct side of the sheet, rather than intersecting it. In the case of an
   alpha helix between (in sequence order) two parallel beta strands, the 
   correct side is one that makes a right hand (screw) turn, as in figure 2 of
   Jane Richardson, "Handedness of crossover connections in beta sheets", PNAS
   Vol. 73, No. 8, August 1976, pp. 2619 - 2623. This side is defined according
   to the up[] direction of the strand before the helix, and the placement (to the
   left or right of this strand) of the strand after the helix, so it makes sense
   even if these two strands are antiparallel.                                   */

	 if(move_helices)
	 for( ib = 0; ib < betaCount - 1; ++ib) 
	  if( nCoilPieces[ib] > 1 ) {

/* Compute plane to move the helices away from, using averages of the plane
   and center data returned by the zipping routines.                           */

	    if(position[ib] < position[ib+1] ) {
	       strand = position[ib];
	       stop = position[ib + 1];
	       }
	    else {
	       strand = position[ib + 1];
	       stop = position[ib];
	       }
	    for(j = 0; j < 3; ++j)
	       averagePlane[j] = 0.;
	    for(i = strand; i < stop; ++i)
	       for(j = 0; j < 3; ++j)
	          averagePlane[j] += plane[i][j];
	    den = 0.;
	    for (j = 0; j < 3; ++j)
	       den += averagePlane[j]*averagePlane[j];
	    den = sqrt(den);
	    for (j = 0; j < 3; ++j)
	       averagePlane[j] /= den;

// Make averageCenter the average of the two strand endpoints that are connected
// by this stretch of coils and helices.
	       
	    int strand0 = positionInverse[ib];
	    int strand1 = positionInverse[ib+1];
	    residue0 = state->protein->pickResidue(bestEnd[strand0][ic]);
	    residue1 = state->protein->pickResidue(bestBegin[strand1][ic]);
	    carboxyl0 = residue0->getCarboxyl();
	    carboxyl1 = residue1->getCarboxyl();
	    Point C0 = carboxyl0.getMajorAtom()->getPosition();
	    Point C1 = carboxyl1.getMajorAtom()->getPosition();
	    averageCenter = Geometry::mid(C0, C1);

	    for (np = 0; np < nAlphaPieces[ib]; ++np) {
	       thisAlpha = alphaPiece[ib][np];
	       if(coreAlpha[thisAlpha]) continue;

//  Do not attempt to move helices that are directly adjacent to beta strands.

	       if(np == 0 && firstCoil[ib] != 1) {
		  printf("Did not attempt to move first helix for strand %d.\n",
		     ib);
	          continue;
		  }
	       if(np == nAlphaPieces[ib] - 1 && lastCoil[ib] != 1) {
		     printf("Did not attempt to move last helix for strand %d.\n",
		        ib);
		     continue;
		     }
	       if(0) printf("moving alphaPiece[%d][%d]\n", ib, np);
	       Protein::StructureSelector movingStrand = state->protein->pickStructure(thisAlpha);
	       if(0) printf("alphaPiece[%d][%d] = %d\n", ib, np, thisAlpha);
	       state->interactor->selectStructure(movingStrand);
               state->interactor->clearCoilRegions();
	       cp = coilPiece[ib][np];
	       state->interactor->toggleCoil(state->protein->pickStructure(cp));
	       if(0) printf("BuildBeta toggled left coil %d\n", cp);
	       for(nq = np + 1; nq < nCoilPieces[ib]; ++nq) {
		  cq = coilPiece[ib][nq];
	          state->interactor->toggleCoil(state->protein->pickStructure(cq));
	          if(0) printf("BuildBeta toggled right coil %d\n", cq);
		  }

// Compute axis of helix, using first four carboxyl carbons.

	       int count = alphaEnd[thisAlpha] + 1 - alphaBegin[thisAlpha];
	       for (j = 0; j < count; ++j) {
	          residue = state->protein->pickResidue(j + alphaBegin[thisAlpha]
		      + firstResiduePlus);
		  carboxyl = residue->getCarboxyl();
		  CC[j] = carboxyl.getMajorAtom()->getPosition();
		  if(0) printf("CC[%d] = %f %f %f\n", j, CC[j][0], CC[j][1], CC[j][2]);
		  }
	       if(0) printf("alphaBegin[thisAlpha] %d alphaEnd[thisAlpha] %d\n",
	          alphaBegin[thisAlpha], alphaEnd[thisAlpha]);
	       double phi[count], psi[count];
	       state->protein->getDihedralAngles(alphaBegin[thisAlpha], count,
	          phi, psi);
	       Vector C1 = Geometry::normalize(Geometry::mid(CC[2], CC[0]) - CC[1]);
	       Vector C2 = Geometry::normalize(Geometry::mid(CC[3], CC[1]) - CC[2]);
	       Vector CE = Geometry::normalize(Geometry::mid(CC[count-1],
	          CC[count-1 - 2]) - CC[count-1 - 1]);
	       Vector axis = Geometry::normalize( Geometry::cross(C1, C2) );
	       Vector DC = CC[2] - CC[1];
	       double dt = dot(DC, axis);
	       Vector DH;
	       for(j = 0; j < 3; ++j)
	         DH[j] = DC[j] - dt*axis[j];
	       float lh = sqrt(DH[0]*DH[0] + DH[1]*DH[1] + DH[2]*DH[2]);
	       float cost = dot(C1, C2);
	       float sina = sqrt (.5-.5*cost);
	       float rad = lh/(2.*sina);
	       Point Center, firstCenter, lastCenter;
	       for(j = 0; j < 3; ++j) {
	          firstCenter[j] = CC[1][j] + rad*C1[j];
	          lastCenter[j]  = CC[count-1 - 1][j] + rad*CE[j];
		  }
	       Center = Geometry::mid(firstCenter, lastCenter);
	       if(0) printf("centerdot %f cdist %f\n",
	          dot(lastCenter - firstCenter, axis) /
	          sqrt(dot(lastCenter - firstCenter, lastCenter - firstCenter)),
		  dot(Center - averageCenter, axis));
	       MD::Scalar angle1, angle2, PI = 3.141592653589793238462643383;
	       dt = dot(axis, averagePlane);

//  Rotate helix axis to be parallel to average beta sheet plane.

	       angle1 = - PI/2. + Math::acos(dt);
	       Vector axis1 = Geometry::cross(axis, averagePlane);
	       Transformation trans1 =
	          Transformation::rotate(Transformation::Rotation::rotateAxis(axis1,angle1));
	       Transformation goalTransformation=Transformation::identity;
	       goalTransformation.leftMultiply(trans1);

//  Rotate helix axis to go in the direction between ends of anchors.

               int e0 = betaStart[ib] + betaLength[ib] - 1;
	       int e1 = betaStart[ib+1];
	       int le1 = betaStart[ib];
	       if(0) printf("ib %d e0 %d e1 %d le1 %d  %d \n", ib, e0, e1, le1,  betaStart[ib]);
	       residue0 = state->protein->pickResidue(e0 + firstResiduePlus);
	       Point carboxyl0 = residue0->getCarboxyl().getMajorAtom()->getPosition();
	       residue1 = state->protein->pickResidue(e1 + firstResiduePlus);
	       Point carboxyl1 = residue1->getCarboxyl().getMajorAtom()->getPosition();
	       residue2 = state->protein->pickResidue(e1 + 1 + firstResiduePlus);
	       Point carboxyl2 = residue2->getCarboxyl().getMajorAtom()->getPosition();
	       residue3 = state->protein->pickResidue(e1 + 2 + firstResiduePlus);
	       Point carboxyl3 = residue3->getCarboxyl().getMajorAtom()->getPosition();
	       lresidue1 = state->protein->pickResidue(le1 + firstResiduePlus);
	       Point lcarboxyl1 = lresidue1->getCarboxyl().getMajorAtom()->getPosition();
	       lresidue2 = state->protein->pickResidue(le1 + 1 + firstResiduePlus);
	       Point lcarboxyl2 = lresidue2->getCarboxyl().getMajorAtom()->getPosition();
	       lresidue3 = state->protein->pickResidue(le1 + 2 + firstResiduePlus);
	       Point lcarboxyl3 = lresidue3->getCarboxyl().getMajorAtom()->getPosition();
	       Vector db = carboxyl1 - carboxyl0;
	       axis = trans1.transform(axis);
	       dt = dot(db, axis)/sqrt(db[0]*db[0] + db[1]*db[1] + db[2]*db[2]);
	       angle2 = acos(dt);
	       if(dot(Geometry::cross(axis, db), averagePlane) < 0)
	          angle2 = - angle2;
	       Transformation trans2 =
	          Transformation::rotate(Transformation::Rotation::rotateAxis(
	          averagePlane, angle2));
	       goalTransformation.leftMultiply(trans2);

//  Translate helix to be spacing away from average beta sheet plane.

	       Point Center1 = goalTransformation.transform(Center);
	       DH = averageCenter - Center1;
	       Vector disp, DG;
	       DG = Geometry::mid(carboxyl2, carboxyl1) - averageCenter;
	       dt = dot(DG, averagePlane);
	       for(j = 0; j < 3; ++j) {
		  DG[j] -= dt*averagePlane[j];
	          disp[j] = DG[j] + DH[j] + (np + 1)*spacing*averagePlane[j];
		  }
	       Transformation trans3=Transformation::translate(disp);
	       goalTransformation.leftMultiply(trans3);
	       if(interact > 1 && gaveup == 8) {
                  printf("IK residual %g  ", lastIKResidual);
		  printf("before moving  helix %d in strand %d\n", np, ib);
                  printf("type r for very early return, any other character to continue \a");
                  if(getchar() == 'r') {
		         state->proteinRenderer->updateStructureFlags();
	             return;
	             }
	          }

	       applyTransformation(goalTransformation);

	       state->interactor->selectStructure(MD::Protein::StructureSelector());
               state->proteinRenderer->updateProtein();
	       updateProteinNow();

               printf("IK residual for helix  %g\n", lastIKResidual);
	       if(0 && lastIKResidual > .000000000001) {

	          if(interact > 1) {
		     printf("before replacing anchors for helix %d in strand %d\n",
		        np, ib);
                     printf("type r to early return, any other character to continue \a");
                     if(getchar() == 'r') {
		            state->proteinRenderer->updateStructureFlags();
	                return;
	                }
	             }

//   Put back first anchor where it belongs

	          Point lnewcarboxyl1 =
		     lresidue1->getCarboxyl().getMajorAtom()->getPosition();
	          Point lnewcarboxyl2 =
		     lresidue2->getCarboxyl().getMajorAtom()->getPosition();
	          Point lnewcarboxyl3 =
		     lresidue3->getCarboxyl().getMajorAtom()->getPosition();
		  if(fixp) printf("lnewcarboxyl1 %f %f %f\n",
		     lnewcarboxyl1[0], lnewcarboxyl1[1], lnewcarboxyl1[2]);
		  if(fixp) printf("lnewcarboxyl2 %f %f %f\n",
		     lnewcarboxyl2[0], lnewcarboxyl2[1], lnewcarboxyl2[2]);
		  if(fixp) printf("lnewcarboxyl3 %f %f %f\n",
		     lnewcarboxyl3[0], lnewcarboxyl3[1], lnewcarboxyl3[2]);

//   First rotate to align vectors between first two carboxyls.

		  axis1 = normalize(Geometry::cross(lcarboxyl2 - lcarboxyl1,
		     lnewcarboxyl2 - lnewcarboxyl1));
		  dt = dot(lcarboxyl2 - lcarboxyl1, lnewcarboxyl2 - lnewcarboxyl1) /
		     sqrt(dot(lcarboxyl2 - lcarboxyl1, lcarboxyl2 - lcarboxyl1) *
		     dot(lnewcarboxyl2 - lnewcarboxyl1, lnewcarboxyl2 - lnewcarboxyl1));
		  angle1 = acos(dt);
	          Transformation tempTransformation=Transformation::identity;
	          trans1 = Transformation::rotate(
		     Transformation::Rotation::rotateAxis(axis1,-angle1));
    	          tempTransformation.leftMultiply(trans1);
	          Point lncarboxyl1 = tempTransformation.transform(lnewcarboxyl1);
	          Point lncarboxyl2 = tempTransformation.transform(lnewcarboxyl2);
	          Point lncarboxyl3 = tempTransformation.transform(lnewcarboxyl3);

//   Find component of C3 - C1 perpendicular to C2 - C1.

		  axis = normalize(lcarboxyl2 - lcarboxyl1);
		  dt = dot(lcarboxyl3 - lcarboxyl1, axis);
		  double newdt = dot(lncarboxyl3 - lncarboxyl1, axis);
		  Vector CM, newCM;
		  for (j = 0; j < 3; ++j) {
		     CM[j] = lcarboxyl3[j] - lcarboxyl1[j] - dt*axis[j];
		     newCM[j] = lncarboxyl3[j] - lncarboxyl1[j] - newdt*axis[j];
		     }
		  dt = dot(newCM, CM)/sqrt(dot(CM, CM)*dot(newCM, newCM));

//   Rotate to align C3's.

		  angle2 = acos(dt);
		  if(dot(Geometry::cross(newCM, CM), axis) < 0)
		     angle2 = - angle2;
		  if(fixp) printf("angle1 %f angle2 %f\n", angle1*180./PI, angle2*180./PI);
		  trans2 = Transformation::rotate(
		     Transformation::Rotation::rotateAxis(axis, angle2));
  		  tempTransformation.leftMultiply(trans2);
		  Point lnwcarboxyl1 = tempTransformation.transform(lnewcarboxyl1);
		  if(fixp) printf("lnwcarboxyl1 %f %f %f\n",
		     lnwcarboxyl1[0], lnwcarboxyl1[1], lnwcarboxyl1[2]);
		  disp = lcarboxyl1 - lnwcarboxyl1;
	          Transformation trans3=Transformation::translate(disp);
	          tempTransformation.leftMultiply(trans3);
	          if(fixp) lncarboxyl1 = tempTransformation.transform(lnewcarboxyl1);
	          if(fixp) lncarboxyl2 = tempTransformation.transform(lnewcarboxyl2);
	          if(fixp) lncarboxyl3 = tempTransformation.transform(lnewcarboxyl3);
	          Point lfincarboxyl1 =
		     lresidue1->getCarboxyl().getMajorAtom()->getPosition();
	          Point lfincarboxyl2 =
		     lresidue2->getCarboxyl().getMajorAtom()->getPosition();
	          Point lfincarboxyl3 =
		     lresidue3->getCarboxyl().getMajorAtom()->getPosition();
		  if(fixp) printf(" lcarboxyl1 %f %f %f\n",
		     lcarboxyl1[0], lcarboxyl1[1], lcarboxyl1[2]);
		  if(fixp) printf("lncarboxyl1 %f %f %f\n",
		     lncarboxyl1[0], lncarboxyl1[1], lncarboxyl1[2]);
		  if(fixp) printf("lfcarboxyl1 %f %f %f\n",
		     lfincarboxyl1[0], lfincarboxyl1[1], lfincarboxyl1[2]);
		  if(fixp) printf(" lcarboxyl2 %f %f %f\n",
		     lcarboxyl2[0], lcarboxyl2[1], lcarboxyl2[2]);
		  if(fixp) printf("lncarboxyl2 %f %f %f\n",
		     lncarboxyl2[0], lncarboxyl2[1], lncarboxyl2[2]);
		  if(fixp) printf("lfcarboxyl2 %f %f %f\n",
		     lfincarboxyl2[0], lfincarboxyl2[1], lfincarboxyl2[2]);
		  if(fixp) printf(" lcarboxyl3 %f %f %f\n",
		     lcarboxyl3[0], lcarboxyl3[1], lcarboxyl3[2]);
		  if(fixp) printf("lncarboxyl3 %f %f %f\n",
		     lncarboxyl3[0], lncarboxyl3[1], lncarboxyl3[2]);
		  if(fixp) printf("lfcarboxyl3 %f %f %f\n",
		     lfincarboxyl3[0], lfincarboxyl3[1], lfincarboxyl3[2]);

//  Form inverse of motion of first anchor

	          goalTransformation=Transformation::identity;
		  trans3 = Transformation::translate( -disp);
		  goalTransformation.leftMultiply(trans3);
		  trans2 = Transformation::rotate(
		     Transformation::Rotation::rotateAxis(axis, - angle2));
		  goalTransformation.leftMultiply(trans2);
	          trans1 = Transformation::rotate(
		     Transformation::Rotation::rotateAxis(axis1, angle1));
    	          goalTransformation.leftMultiply(trans1);
//	          goalTransformation=Transformation::identity;

//   Put back second anchor where it belongs

	          Point newcarboxyl1 =
		     residue1->getCarboxyl().getMajorAtom()->getPosition();
	          Point newcarboxyl2 =
		     residue2->getCarboxyl().getMajorAtom()->getPosition();
	          Point newcarboxyl3 =
		     residue3->getCarboxyl().getMajorAtom()->getPosition();
		  if(fixp) printf("newcarboxyl1 %f %f %f\n",
		     newcarboxyl1[0], newcarboxyl1[1], newcarboxyl1[2]);
		  if(fixp) printf("newcarboxyl2 %f %f %f\n",
		     newcarboxyl2[0], newcarboxyl2[1], newcarboxyl2[2]);
		  if(fixp) printf("newcarboxyl3 %f %f %f\n",
		     newcarboxyl3[0], newcarboxyl3[1], newcarboxyl3[2]);

	          nextBeta = betaPiece[ib + 1];
	          movingStrand = state->protein->pickStructure(nextBeta);
	          state->interactor->selectStructure(movingStrand);
//
                  state->interactor->clearCoilRegions();
	          cp = coilPiece[ib][np];
	          state->interactor->toggleCoil(state->protein->pickStructure(cp));
	          for(nq = np + 1; nq < nCoilPieces[ib]; ++nq) {
		     cq = coilPiece[ib][nq];
	             state->interactor->toggleCoil(state->protein->pickStructure(cq));
		     }
//
		  axis1 = normalize(Geometry::cross(carboxyl2 - carboxyl1, newcarboxyl2 - newcarboxyl1));
		  dt = dot(carboxyl2 - carboxyl1, newcarboxyl2 - newcarboxyl1) /
		     sqrt(dot(carboxyl2 - carboxyl1, carboxyl2 - carboxyl1) *
		     dot(newcarboxyl2 - newcarboxyl1, newcarboxyl2 - newcarboxyl1));
		  angle1 = acos(dt);
	          trans1 = Transformation::rotate(
		     Transformation::Rotation::rotateAxis(axis1,-angle1));
	          tempTransformation=Transformation::identity;
    	          tempTransformation.leftMultiply(trans1);
	          Point ncarboxyl1 = tempTransformation.transform(newcarboxyl1);
	          Point ncarboxyl2 = tempTransformation.transform(newcarboxyl2);
	          Point ncarboxyl3 = tempTransformation.transform(newcarboxyl3);
		  axis = normalize(carboxyl2 - carboxyl1);
		  dt = dot(carboxyl3 - carboxyl1, axis);
		  newdt = dot(ncarboxyl3 - ncarboxyl1, axis);
		  for (j = 0; j < 3; ++j) {
		     CM[j] = carboxyl3[j] - carboxyl1[j] - dt*axis[j];
		     newCM[j] = ncarboxyl3[j] - ncarboxyl1[j] - newdt*axis[j];
		     }
		  dt = dot(newCM, CM)/sqrt(dot(CM, CM)*dot(newCM, newCM));
		  angle2 = acos(dt);
		  if(dot(Geometry::cross(newCM, CM), axis) < 0)
		     angle2 = - angle2;
		  if(fixp) printf("angle1 %f angle2 %f\n", angle1*180./PI, angle2*180./PI);
		  trans2 = Transformation::rotate(
		     Transformation::Rotation::rotateAxis(axis,angle2));
  		  tempTransformation.leftMultiply(trans2);
		  Point nwcarboxyl1 = tempTransformation.transform(newcarboxyl1);
		  if(fixp) printf("nwcarboxyl1 %f %f %f\n",
		     nwcarboxyl1[0], nwcarboxyl1[1], nwcarboxyl1[2]);
		  disp = carboxyl1 - nwcarboxyl1;
	          trans3 = Transformation::translate(disp);
	          tempTransformation.leftMultiply(trans3);
	          if(fixp) ncarboxyl1 = tempTransformation.transform(newcarboxyl1);
	          if(fixp) ncarboxyl2 = tempTransformation.transform(newcarboxyl2);
	          if(fixp) ncarboxyl3 = tempTransformation.transform(newcarboxyl3);

		  goalTransformation.leftMultiply(trans1);
		  goalTransformation.leftMultiply(trans2);
		  goalTransformation.leftMultiply(trans3);
		  
	          applyTransformation(goalTransformation);

                  printf("IK residual after moving anchors %g\n", lastIKResidual);
	          state->interactor->selectStructure(MD::Protein::StructureSelector());
                  state->proteinRenderer->updateProtein();
	          updateProteinNow();
	          Point fincarboxyl1 =
		     residue1->getCarboxyl().getMajorAtom()->getPosition();
	          Point fincarboxyl2 =
		     residue2->getCarboxyl().getMajorAtom()->getPosition();
	          Point fincarboxyl3 =
		     residue3->getCarboxyl().getMajorAtom()->getPosition();
		  if(fixp) printf(" carboxyl1 %f %f %f\n",
		     carboxyl1[0], carboxyl1[1], carboxyl1[2]);
		  if(fixp) printf("ncarboxyl1 %f %f %f\n",
		     ncarboxyl1[0], ncarboxyl1[1], ncarboxyl1[2]);
		  if(fixp) printf("fcarboxyl1 %f %f %f\n",
		     fincarboxyl1[0], fincarboxyl1[1], fincarboxyl1[2]);
		  if(fixp) printf(" carboxyl2 %f %f %f\n",
		     carboxyl2[0], carboxyl2[1], carboxyl2[2]);
		  if(fixp) printf("ncarboxyl2 %f %f %f\n",
		     ncarboxyl2[0], ncarboxyl2[1], ncarboxyl2[2]);
		  if(fixp) printf("fcarboxyl2 %f %f %f\n",
		     fincarboxyl2[0], fincarboxyl2[1], fincarboxyl2[2]);
		  if(fixp) printf(" carboxyl3 %f %f %f\n",
		     carboxyl3[0], carboxyl3[1], carboxyl3[2]);
		  if(fixp) printf("ncarboxyl3 %f %f %f\n",
		     ncarboxyl3[0], ncarboxyl3[1], ncarboxyl3[2]);
		  if(fixp) printf("fcarboxyl3 %f %f %f\n",
		     fincarboxyl3[0], fincarboxyl3[1], fincarboxyl3[2]);
		  if(lastIKResidual > .0000000001)
		     good = 0;
		  }
	       } 
          }
	  
	 if (move_helices && (1 || good)) {

// output new structure a second time, overwriting first try.

	    strcpy(outputfilename, protein_name);
	    strcat(outputfilename, ".movedhelices.");
	    sprintf(digits, "%d", succeeded);
	    printf("wrote file %d ", succeeded);
	    strcat(outputfilename, digits);
	    strcat(outputfilename, ".up");
	    printf("up ");
	    for (k = 0; k < betaCount; ++k) {
	       sprintf(digits, "%d", up[k]);
	       printf("%d ", up[k]);
	       strcat(outputfilename, digits);
	       }
	    strcat(outputfilename, ".pos");
	    printf(" position ");
	    for (k = 0; k < betaCount; ++k) {
	       sprintf(digits, "%d", position[k]);
	       printf("%d ", position[k]);
	       positionInverse[position[k]] = k;
	       strcat(outputfilename, digits);
	       }
	    printf(" position inverse ");
	    for (k = 0; k < betaCount; ++k) {
	       printf("%d ", positionInverse[k]);
	       }
	    strcat(outputfilename, ".od");
	    sprintf(digits, "%d", od);
	    strcat(outputfilename, digits);
	    strcat(outputfilename, ".short");
	    sprintf(digits, "%d", shortcount);
	    strcat(outputfilename, digits);
	    strcat(outputfilename, ".IngoScore");
	    sprintf(digits, "%7f", bestTopologyProbability[jt]);
	    strcat(outputfilename, digits);
	    strcat(outputfilename, ".ZhuEnergy");
	    sprintf(digits, "%4.2f", bestTotalE[ic]);
	    strcat(outputfilename, digits);
	    strcat(outputfilename, ".pdb");
            writePdbFile(*state->protein, outputfilename);
	    printf("\n");
	    fprintf(stderr, "wrote file %s\n", outputfilename);
	    printf("wrote file %s\n", outputfilename);
	    if(offlineBuildBeta == 0 && interact) fprintf(stderr, "\a");
	    fflush(NULL);
	    }
   
	 if(interact) {
	    printf("after moving helices and anchors\n");
            printf("type r to return, any other character to continue \a");
            if(getchar() == 'r') {
		   state->proteinRenderer->updateStructureFlags();
	       return;
	       }
	    }
	 ++alignments;
	 ++foundThisTopology;
   giveUp: ;

// now lengthen strands starting from strand ends outward

	 if(shpr) printf("before lengthening: firstResiduePlus %d\n",
	    firstResiduePlus);
	 if(printStruct) printStructure(state->protein);
	 if(shorten) {
	   for (strand = 0; strand < betaCount; ++strand) {
	    i = positionInverse[strand];
	    if(coreBeta[i]) break;
	    b0 = bestBegin[strand][ic];
	    e0 = bestEnd[strand][ic];
	    add = 0;
	    if (strand > 0)
	       if(up[strand] == up[strand - 1]) add = 1;
	    if (strand < betaCount - 1)
	       if(up[strand] == up[strand + 1]) add = 1;
	    if(shpr) printf(
	       "i %d begin %d end %d add %d betaStart %d betaEnd %d\n",
	       i, b0 - add, e0 + add, add, betaStart[i],
	       betaStart[i] + betaLength[i] - 1);
	    lengthened = 0;
	    if (i > 0 && lastCoil[i - 1] == 1)
	     for(j = b0 - add - 1; j >= betaStart[i]; --j) {
	       if(shorten > 1)
		  for (m = -1; m <= 1; ++m)
	          std::cout << state->protein->pickResidue(j + m + firstResiduePlus)
		       << "  "
	               << (state->protein->pickResidue(j + m + firstResiduePlus))->getSecondaryStructure()->getStructureType()
		       << "\n";
	       state->protein->changeResidueStructureType(
	          state->protein->pickResidue(j + firstResiduePlus),
	          Protein::SecondaryStructure::BETA_STRAND);
	       ++longcount;
	       if(0 && pred[j] != 'E') 
	          printf("Changed original %s residue to E\n", pred[j]);
	       lengthened = 1;
	       if(shorten > 1) printf("changed residue %d to BETA_STRAND\n",
	          j + firstResidueIndex);
	       if(shorten > 1) {
		  for (m = -1; m <= 1; ++m)
	          std::cout << state->protein->pickResidue(j + m + firstResiduePlus)
		       << "  "
	               << (state->protein->pickResidue(j + m + firstResiduePlus))->getSecondaryStructure()->getStructureType()
		       << "\n";
		  std::cout << "\n";
		  }
	       } 
	    if (i < betaCount - 1 && firstCoil[i] == 1)
	     for (j = e0 + add + 1; j < betaStart[i] + betaLength[i]; ++j) {
	       if(shorten > 1)
		  for (m = -1; m <= 1; ++m)
	          std::cout << state->protein->pickResidue(j + m + firstResiduePlus)
		       << "  "
	               << (state->protein->pickResidue(j + m + firstResiduePlus))->getSecondaryStructure()->getStructureType()
		       << "\n";
	       state->protein->changeResidueStructureType(
	          state->protein->pickResidue(j + firstResiduePlus),
	          Protein::SecondaryStructure::BETA_STRAND);
	       ++longcount;
	       if(0 && pred[j] != 'E') 
	          printf("Changed original %s residue to E\n", pred[j]);
	       lengthened = 1;
	       if(shorten > 1) printf("changed residue %d to BETA_STRAND\n",
	          j + firstResidueIndex);
	       if(shorten > 1) {
		  for (m = -1; m <= 1; ++m)
	          std::cout << state->protein->pickResidue(j + m + firstResiduePlus)
		       << "  "
	               << (state->protein->pickResidue(j + m + firstResiduePlus))->getSecondaryStructure()->getStructureType()
		       << "\n";
		  std::cout << "\n";
		  }
	       } 
	    if(coilPrint && lengthened) printf(
	       "lengthening strand %d b0 %d e0 %d betastart %d betaEnd %d\n",
	       i, b0, e0, betaStart[i], betaStart[i] + betaLength[i] - 1);
	    state->proteinRenderer->updateStructureFlags();
	    }
	   if(longcount != shortcount) {
	       printf("longcount %d shortcount %d\n",
	          longcount, shortcount);
	       }
	   } 
	 if(shpr) printf("after lengthening\n");
	 if(printStruct) printStructure(state->protein);
skipCase: ;
  	 if(alignments >= ALIGNMENTS) break;
	 }
      }
      if(foundThisTopology >= FIND_PER_TOPOLOGY) ++topologies;
      if(1 && topologies >= enough_topologies) {
         printf("early end to topology loop; found %d topologies\n",
	   topologies);
	 break;
	 }
    }
   printf("succeeded %d   gave up %d  skippedCase %d  zipProline %d\a\n",
      succeeded, gaveup, skippedCase, zipProline);
   fprintf(stderr, "succeeded %d  gave up %d  skippedCase %d  zipProline %d\a\n",
      succeeded, gaveup, skippedCase, zipProline);
   fflush(NULL);
   }
}
